# Task #28: subnet.service_endpoint_policy_ids

## Summary
Implemented `subnet.service_endpoint_policy_ids` field mapping from Terraform variable to Azure API `serviceEndpointPolicies` array. The field is optional and transforms a set of policy ID strings into an array of objects with `id` properties.

## Shadow Implementation
```hcl
# In migrate_main.tf, within subnet properties block:
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          properties = {
            serviceEndpointPolicies = subnet.service_endpoint_policy_ids != null && length(subnet.service_endpoint_policy_ids) > 0 ? [  # <-
              for policy_id in subnet.service_endpoint_policy_ids : {                                                                       # <-
                id = policy_id                                                                                                               # <-
              }                                                                                                                              # <-
            ] : null                                                                                                                         # <-
          }
        }
      ] : null
    }
  }
}
```

## Create Phase Verification

**Pattern Identification:**
Queried `resourceVirtualNetworkCreate` function - shows single-phase creation pattern with one `CreateOrUpdateThenPoll` call.

**Go Code Evidence:**
```go
// From resourceVirtualNetworkCreate
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	// ... vnet construction ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// Single CreateOrUpdateThenPoll - no additional operations after
	// ... state polling ...
	return resourceVirtualNetworkRead(d, meta)
}
```

**Field Processing:**
The `service_endpoint_policy_ids` field is processed during the **Create phase** within the primary `CreateOrUpdateThenPoll` operation. Evidence from `expandVirtualNetworkProperties`:

```go
// From expandVirtualNetworkProperties
subnetObj.Properties.ServiceEndpointPolicies = expandVirtualNetworkSubnetServiceEndpointPolicies(subnet["service_endpoint_policy_ids"].(*pluginsdk.Set).List())
```

**Decision:**
Field belongs in `local.body.properties.subnets[*].properties` (Create phase).

## Assignment Path Verification

**Predicted Path:**
`body` → `properties` → `subnets` → `[array elements]` → `properties` → `serviceEndpointPolicies`

**Go Code Evidence - Full Assignment Chain:**

1. **Create function constructs VNet object:**
```go
// From resourceVirtualNetworkCreate
vnet := virtualnetworks.VirtualNetwork{
	Properties: vnetProperties,  // <-- Properties assigned here
}
```

2. **Properties returned from expand function:**
```go
// From expandVirtualNetworkProperties
properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
	Subnets: &subnets,  // <-- Subnets assigned here
}
return properties, &routeTables, nil
```

3. **Subnet object constructed in loop:**
```go
// From expandVirtualNetworkProperties
for _, subnet := range subs.List() {
	subnetObj.Properties.ServiceEndpointPolicies = expandVirtualNetworkSubnetServiceEndpointPolicies(...)
	// ^-- ServiceEndpointPolicies assigned to subnetObj.Properties
	subnets = append(subnets, *subnetObj)
}
```

4. **Expand function transforms IDs to objects:**
```go
// From expandVirtualNetworkSubnetServiceEndpointPolicies
func expandVirtualNetworkSubnetServiceEndpointPolicies(input []interface{}) *[]virtualnetworks.ServiceEndpointPolicy {
	output := make([]virtualnetworks.ServiceEndpointPolicy, 0)
	for _, policy := range input {
		policy := policy.(string)
		output = append(output, virtualnetworks.ServiceEndpointPolicy{Id: &policy})
		// ^-- Creates object with Id field from string
	}
	return &output
}
```

**Verified Path:**
`VirtualNetwork.Properties.Subnets[].Properties.ServiceEndpointPolicies[]` where each element is an object with `Id` field.

**Path Comparison:**
✅ MATCH - The predicted path matches the actual assignment path in provider code.

**Assignment Trace:**
- `vnet.Properties` ← assigned from `vnetProperties`
- `vnetProperties.Subnets` ← assigned from `&subnets` slice
- `subnets[i].Properties.ServiceEndpointPolicies` ← assigned from expand function
- Each array element has `.Id` field set to the policy ID string

## Provider Schema

**Go Source (PRIMARY):**
```go
// From resourceVirtualNetworkSchema() - subnet block
"service_endpoint_policy_ids": {
	Type:     pluginsdk.TypeSet,
	Optional: true,
	Elem: &pluginsdk.Schema{
		Type:         pluginsdk.TypeString,
		ValidateFunc: serviceendpointpolicies.ValidateServiceEndpointPolicyID,
	},
},
```

**Key Attributes:**
- **Type:** `TypeSet` (set of strings)
- **Required:** No (`Optional: true`)
- **ForceNew:** No (not specified)
- **ValidateFunc:** `serviceendpointpolicies.ValidateServiceEndpointPolicyID` - validates resource ID format
- **Sensitive:** No
- **Computed:** No
- **DiffSuppressFunc:** None

## Azure API Schema

**Resource Type:** `Microsoft.Network/virtualNetworks@2024-07-01`

**Property Path:** `body.properties.subnets[].properties.serviceEndpointPolicies`

**API Schema (from query):**
```
serviceEndpointPolicies: List(ObjectWithOptionalAttrs(map[string]Type{
  "id": String, 
  "location": String, 
  "properties": ObjectWithOptionalAttrs(...), 
  "tags": Map(String)
}, []string{"id", "location", "properties", "tags"}))
```

**Key Characteristics:**
- **Type:** Array of objects
- **Required:** No (optional attribute)
- **Object Structure:** Each element can have `id`, `location`, `properties`, `tags`
- **Provider Behavior:** Provider only sends `id` field (minimal object structure)

## Hidden Fields

**Investigation:**
Checked expand function `expandVirtualNetworkSubnetServiceEndpointPolicies` - no hidden fields found.

**Evidence:**
```go
func expandVirtualNetworkSubnetServiceEndpointPolicies(input []interface{}) *[]virtualnetworks.ServiceEndpointPolicy {
	output := make([]virtualnetworks.ServiceEndpointPolicy, 0)
	for _, policy := range input {
		policy := policy.(string)
		output = append(output, virtualnetworks.ServiceEndpointPolicy{Id: &policy})
		// Only Id field is set - no hidden fields
	}
	return &output
}
```

**Conclusion:** No hidden fields. Only the `id` field is populated from user input.

## Mapping

**Terraform → Azure API:**
- `subnet.service_endpoint_policy_ids` (set of strings) → `properties.subnets[].properties.serviceEndpointPolicies` (array of objects with `id` field)

**Naming Convention:**
- Snake case: `service_endpoint_policy_ids`
- Camel case: `serviceEndpointPolicies`

**Transformation:**
```
Input:  set(string) = ["policy-id-1", "policy-id-2"]
Output: [{id: "policy-id-1"}, {id: "policy-id-2"}]
```

## Special Handling

### Validation (MANDATORY - Implemented)

**Provider Validation:**
```go
ValidateFunc: serviceendpointpolicies.ValidateServiceEndpointPolicyID,
```

This validates that each policy ID matches the Service Endpoint Policy resource ID format.

**Implementation in variables.tf:**
```hcl
validation {
  condition = var.subnet == null || alltrue([
    for s in var.subnet : s.service_endpoint_policy_ids == null || alltrue([
      for policy_id in s.service_endpoint_policy_ids : can(regex("^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\\.Network/serviceEndpointPolicies/[^/]+$", policy_id))
    ])
  ])
  error_message = "Each service_endpoint_policy_ids must be a valid Service Endpoint Policy resource ID in the format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}"
}
```

### ForceNew Behavior

**Schema Check:** No `ForceNew: true` attribute found.

**CustomizeDiff Check:** Reviewed `resourceVirtualNetwork()` function - no CustomizeDiff logic found for this field.

**Conclusion:** This field does NOT trigger resource replacement. It can be updated in-place.

**Implementation:** Not added to `replace_triggers_external_values`.

### Sensitive Fields

**Check:** Not marked as `Sensitive: true` in schema.

**Implementation:** Field value placed in `local.body` (not `sensitive_body`).

### Conditional Logic

**Implementation Strategy:**
```hcl
serviceEndpointPolicies = subnet.service_endpoint_policy_ids != null && length(subnet.service_endpoint_policy_ids) > 0 ? [
  for policy_id in subnet.service_endpoint_policy_ids : {
    id = policy_id
  }
] : null
```

**Rationale:**
- Check both `!= null` and `length() > 0` to handle empty sets
- Return `null` when no policies specified (ignored by `ignore_null_property = true`)
- Transform each string ID into an object with `id` field

## Deferred Work Completion

**Check:** Reviewed `following.md` - file does not exist, no deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics:**
- `null` → No policies configured, API field not sent (`ignore_null_property = true`)
- Empty set `[]` → Same as null (condition checks both null and length)

**2. Empty String Values:**
- Validation prevents empty strings (resource ID regex requires non-empty segments)
- User cannot provide `[""]` - will fail validation

**3. Duplicate IDs:**
- Input type is `set(string)` in variables.tf, Terraform automatically deduplicates
- No special handling needed

**4. Order Stability:**
- Input is a set (unordered), converted to list via `for` expression
- Order may vary between applies but doesn't affect functionality (Azure API doesn't care about order)
- Idempotent: Same set of IDs produces equivalent API payload

**5. Null Safety:**
- Safe reference: Checks `!= null` and `length() > 0` before iteration
- No risk of null pointer errors

**6. Boundary Conditions:**
- Zero policies: Returns `null`, field omitted from API payload
- One policy: Returns single-element array
- Multiple policies: Returns array with all elements
- No schema-level limit on number of policies

**7. Invalid References:**
- Resource ID validation catches malformed IDs at plan time
- Non-existent policy IDs will fail during Azure API call (expected behavior)

**8. Integration with Other Fields:**
- Independent of `service_endpoints` field (no conflicts)
- Can be specified even if `service_endpoints` is null
- No cross-field dependencies

## Checklist

- ✅ Property in correct local (`body.properties.subnets[*].properties.serviceEndpointPolicies`)
- ✅ ForceNew: Not applicable (field supports in-place updates)
- ✅ All logic EXACTLY replicated from provider (simple transformation, no complex logic)
- ✅ Validations IMPLEMENTED in variables.tf (resource ID format validation)
- ✅ TODO comment: Not applicable (not a sensitive field requiring independent ephemeral variable)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: Not applicable (no work deferred to other tasks)
- ✅ Deferred work from following.md: None (file doesn't exist)
- ✅ Critical review (null handling, edge cases, idempotency, safe references)
- ✅ Edge Case Analysis in proof (included above)
- ✅ Proof created (this document)
- ✅ Track.md status: Will update to "Pending for check"
- ✅ Self-Review: Only implemented service_endpoint_policy_ids field (Task #28), did not add fields from other tasks

## Implementation Exactly Matches Provider Behavior

The implementation transforms the input set of policy ID strings into an array of objects with `id` fields, exactly matching the provider's `expandVirtualNetworkSubnetServiceEndpointPolicies` function behavior. No shortcuts, no simplifications - exact replication of provider logic.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #28 - subnet.service_endpoint_policy_ids

### Validation Results

✅ **ForceNew Logic:** Not applicable (field has ForceNew: false, can be updated in-place)
✅ **Stable Keys:** Not applicable (field not in replace_triggers_external_values)
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** Correct conversion from `set(string)` to array of objects with `id` field
✅ **Null Handling:** Safe - checks both `!= null` and `length() > 0` before iteration
✅ **Validations:** Resource ID format validation implemented in variables.tf (lines 278-285)
✅ **Transformation Logic:** Exactly replicates provider's `expandVirtualNetworkSubnetServiceEndpointPolicies` function
✅ **Deferred Work Completion:** No deferred work for this task (following.md doesn't exist)
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** Comprehensive analysis - null semantics, empty sets, duplicates, order stability, invalid references
✅ **Hidden Fields:** None found (verified in expand function)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The transformation logic precisely matches the provider's expand function - converting each string ID from the input set into an object with an `id` field. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Points:**
- Validation implemented in `variables.tf` as MANDATORY (executor.md lines 110-126)
- Direct assignment with proper null handling (executor.md lines 170-191)
- Correct phase detection and placement in `local.body` (executor.md lines 445-446)
- Type conversion exactly matches provider: `set(string)` → `[{id: string}]`
- Safe iteration with null checks before accessing elements

**Status:** APPROVED ✅

---
