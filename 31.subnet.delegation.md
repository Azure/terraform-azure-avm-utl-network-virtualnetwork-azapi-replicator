# Task #31 - subnet.delegation - Block Structure Skeleton

## Summary
Created structure skeleton for the nested block `subnet.delegation` with comment placeholders for child arguments (Tasks #32, #33-35). The delegation block is conditionally rendered when present in the subnet configuration.

## Create Phase Verification

### Query Create Method
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    vnet := virtualnetworks.VirtualNetwork{
        Name:             pointer.To(id.VirtualNetworkName),
        ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
        Location:         pointer.To(location.Normalize(d.Get("location").(string))),
        Properties:       vnetProperties,
        Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
    }
    // ...
    if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
        return fmt.Errorf("creating %s: %+v", id, err)
    }
    // ...
}
```

### Pattern Identification
**Single-phase operation**: The resource uses a single `CreateOrUpdateThenPoll` call. There are no additional SDK operations after the primary create.

### Field Classification
The `delegation` field is part of the subnet configuration, which is processed in the `expandVirtualNetworkProperties` function called before the primary create. The delegation data flows through:
1. `expandVirtualNetworkProperties` → builds subnet properties
2. `expandVirtualNetworkSubnetDelegation` → builds delegation array
3. Assigned to subnet properties → `subnetObj.Properties.Delegations = expandVirtualNetworkSubnetDelegation(subnet["delegation"].([]interface{}))`

**Decision**: Field belongs in `local.body` (Create phase, included in primary CreateOrUpdate operation).

## Assignment Path Verification

### Predicted Path
`body.properties.subnets[].properties.delegations`

### Go Code Evidence
From `expandVirtualNetworkSubnetDelegation`:
```go
func expandVirtualNetworkSubnetDelegation(input []interface{}) *[]virtualnetworks.Delegation {
    retDelegations := make([]virtualnetworks.Delegation, 0)

    for _, deleValue := range input {
        deleData := deleValue.(map[string]interface{})
        deleName := deleData["name"].(string)
        srvDelegations := deleData["service_delegation"].([]interface{})
        srvDelegation := srvDelegations[0].(map[string]interface{})
        srvName := srvDelegation["name"].(string)

        srvActions := srvDelegation["actions"].(*pluginsdk.Set).List()

        retSrvActions := make([]string, 0)
        for _, srvAction := range srvActions {
            srvActionData := srvAction.(string)
            retSrvActions = append(retSrvActions, srvActionData)
        }

        retDelegation := virtualnetworks.Delegation{
            Name: &deleName,
            Properties: &virtualnetworks.ServiceDelegationPropertiesFormat{
                ServiceName: &srvName,
                Actions:     &retSrvActions,
            },
        }

        retDelegations = append(retDelegations, retDelegation)
    }

    return &retDelegations
}
```

From `expandVirtualNetworkProperties`:
```go
subnetObj.Properties.Delegations = expandVirtualNetworkSubnetDelegation(subnet["delegation"].([]interface{}))
```

Assignment chain:
1. `expandVirtualNetworkSubnetDelegation` returns `*[]virtualnetworks.Delegation`
2. Assigned to `subnetObj.Properties.Delegations` (SubnetPropertiesFormat.Delegations field)
3. `subnetObj` is `virtualnetworks.Subnet`
4. Subnet added to `properties.Subnets` slice
5. `vnet.Properties = vnetProperties` (VirtualNetworkPropertiesFormat)
6. `vnet` becomes the request body

### Verified Path
`body.properties.subnets[].properties.delegations`

### Path Comparison
**MATCH** ✅ - Predicted path matches verified path.

## Provider Schema

From `resourceVirtualNetworkSchema()`:
```go
"delegation": {
    Type:       pluginsdk.TypeList,
    Optional:   true,
    MaxItems:   1,
    ConfigMode: pluginsdk.SchemaConfigModeAttr,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "name": {
                Type:     pluginsdk.TypeString,
                Required: true,
            },
            "service_delegation": {
                Type:       pluginsdk.TypeList,
                Required:   true,
                MaxItems:   1,
                ConfigMode: pluginsdk.SchemaConfigModeAttr,
                Elem: &pluginsdk.Resource{
                    Schema: map[string]*pluginsdk.Schema{
                        "name": {
                            Type:         pluginsdk.TypeString,
                            Required:     true,
                            ValidateFunc: validation.StringInSlice(subnetDelegationServiceNames, false),
                        },

                        "actions": {
                            Type:     pluginsdk.TypeSet,
                            Optional: true,
                            Elem: &pluginsdk.Schema{
                                Type: pluginsdk.TypeString,
                                ValidateFunc: validation.StringInSlice([]string{
                                    "Microsoft.Network/networkinterfaces/*",
                                    "Microsoft.Network/publicIPAddresses/join/action",
                                    "Microsoft.Network/publicIPAddresses/read",
                                    "Microsoft.Network/virtualNetworks/read",
                                    "Microsoft.Network/virtualNetworks/subnets/action",
                                    "Microsoft.Network/virtualNetworks/subnets/join/action",
                                    "Microsoft.Network/virtualNetworks/subnets/prepareNetworkPolicies/action",
                                    "Microsoft.Network/virtualNetworks/subnets/unprepareNetworkPolicies/action",
                                }, false),
                            },
                        },
                    },
                },
            },
        },
    },
},
```

**Key Properties:**
- **Type**: List (TypeList) with MaxItems: 1
- **Optional**: true
- **Child blocks**: 
  - `name` (Required, String)
  - `service_delegation` (Required, List with MaxItems: 1)
    - `name` (Required, String with validation)
    - `actions` (Optional, Set of Strings with validation)

## Azure API Schema

From `query_azapi_resource_schema`:
```
List(ObjectWithOptionalAttrs(map[string]Type{
    "id":String, 
    "name":String, 
    "properties":ObjectWithOptionalAttrs(map[string]Type{
        "serviceName":String
    }, []string{"serviceName"}), 
    "type":String
}, []string{"id", "name", "properties", "type"}))
```

**API Structure:**
- Array of delegation objects
- Each delegation has: `id`, `name`, `properties`, `type`
- `properties` contains: `serviceName` (and actions are not visible in schema but present in expand function)

Note: The provider schema shows `actions` in `service_delegation`, which maps to the API's delegation properties.

## Hidden Fields

### Detection Process
Checked `expandVirtualNetworkSubnetDelegation` function for any hardcoded values or fields not in the Terraform schema.

### Analysis
```go
retDelegation := virtualnetworks.Delegation{
    Name: &deleName,
    Properties: &virtualnetworks.ServiceDelegationPropertiesFormat{
        ServiceName: &srvName,
        Actions:     &retSrvActions,
    },
}
```

**Findings:**
- ✅ `Name` - mapped from `name` field (Task #32)
- ✅ `Properties.ServiceName` - mapped from `service_delegation.name` (Task #34)
- ✅ `Properties.Actions` - mapped from `service_delegation.actions` (Task #35)
- ⚠️ `id` and `type` - These are read-only fields returned by the API, not set by the provider

**Conclusion:** NO hidden fields to add. All fields are explicitly mapped from the Terraform configuration. The `id` and `type` fields are computed/read-only and should not be included in the request body.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `delegation` | `delegations` | Array of delegation objects |
| `delegation.name` | `delegation[].name` | Task #32 |
| `delegation.service_delegation` | `delegation[].properties` | Nested object |
| `delegation.service_delegation.name` | `delegation[].properties.serviceName` | Task #34 |
| `delegation.service_delegation.actions` | `delegation[].properties.actions` | Task #35 (Optional) |

## Special Handling

### Structure Type
**Block skeleton** - This is a Type 3 task. Creating only the conditional structure with comment placeholders for child arguments.

### Conditional Rendering
The delegation block is:
1. Optional within each subnet (can be null/absent)
2. A list with MaxItems: 1 in Terraform
3. Converts to an array in the API

The skeleton conditionally includes delegations only when present in the subnet configuration.

### Implementation Pattern
Since `ignore_null_property = true` is set, we can directly assign `null` when delegation is not present. The skeleton uses a conditional expression within the subnet loop to include delegations only when the delegation field exists.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name
          properties = merge(
            # ... existing fields ...
            {
              delegations = subnet.delegation != null && length(subnet.delegation) > 0 ? [ # <-
                for delegation in subnet.delegation : {                                    # <-
                  name = null # Task #32                                                   # <-
                  properties = {                                                           # <-
                    serviceName = null # Task #34                                          # <-
                    actions = null # Task #35                                              # <-
                  }                                                                        # <-
                }                                                                          # <-
              ] : null                                                                     # <-
            }
          )
        }
      ] : null
    }
  }
}
```

## Child Tasks Ready for Delegation

Based on the schema analysis, the following child tasks are now ready to be implemented:

| Task # | Field Path | Type | Required | Notes |
|--------|-----------|------|----------|-------|
| 32 | subnet.delegation.name | Argument | Yes | Delegation name identifier |
| 33 | subnet.delegation.service_delegation | Block | Yes | Service delegation configuration block (skeleton) |
| 34 | subnet.delegation.service_delegation.name | Argument | Yes | Service name with validation (enum) |
| 35 | subnet.delegation.service_delegation.actions | Argument | No | Optional list of delegation actions |

**Note:** Task #33 will create the `service_delegation` block skeleton, while Tasks #34-35 will implement the individual arguments within that block.

## Critical Review & Edge Cases

### Null Semantics
- **`null` delegation**: When `subnet.delegation` is null, the `delegations` field is set to `null` (ignored by AzAPI due to `ignore_null_property = true`)
- **Empty list**: Provider schema allows empty list; handled by `length(subnet.delegation) > 0` check
- **Idempotency**: Array structure with stable ordering maintained through `for` loop

### Edge Cases
1. **Empty delegation list**: `subnet.delegation = []` → results in `delegations = null` (API receives no delegations field)
2. **MaxItems: 1 enforcement**: Terraform schema enforces MaxItems: 1, so delegation list will have at most one element
3. **Null inner objects**: With `ignore_null_property = true`, null values in properties are automatically filtered
4. **List vs single item**: Terraform uses list with MaxItems: 1; API expects array - iteration correctly handles this

### Safe References
- ✅ Check `subnet.delegation != null` before accessing
- ✅ Check `length(subnet.delegation) > 0` before iteration
- ✅ Safe to iterate with `for delegation in subnet.delegation` after null/length checks
- ✅ Individual delegation properties checked in child tasks (#32, #34, #35)

### Boundary Conditions
- **No delegation**: Entire `delegations` field omitted from API request (null ignored)
- **One delegation**: Creates array with single element (expected by API)
- **Multiple delegations**: Not possible due to MaxItems: 1 in schema

## Checklist

- ✅ Skeleton structure created with comment placeholders
- ✅ Conditional rendering based on delegation presence
- ✅ Proper nesting: `properties.subnets[].properties.delegations[]`
- ✅ Hidden fields checked - none found (id and type are read-only)
- ✅ Child tasks identified and documented
- ✅ ForceNew not applicable (block skeleton only)
- ✅ Sensitive fields not applicable
- ✅ Validations not applicable (block skeleton only)
- ✅ Critical review completed
- ✅ Edge case analysis included
- ✅ Proof document created
- ⏳ track.md to be updated to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #31 - subnet.delegation

### Validation Results

✅ **Block Structure Skeleton (Type 3):** Correctly implemented with comment placeholders for child tasks (#32, #34, #35)
✅ **Conditional Rendering:** Proper null and length checks (`subnet.delegation != null && length(subnet.delegation) > 0`)
✅ **Assignment Path:** Verified path `properties.subnets[].properties.delegations[]` matches Go code evidence
✅ **Array Iteration:** Correct iteration pattern for list with MaxItems: 1 converting to API array
✅ **Hidden Fields:** Correctly identified that `id` and `type` are read-only and should not be set
✅ **Child Tasks:** Properly documented tasks #32, #34, #35 ready for implementation
✅ **Edge Cases:** Comprehensive analysis of null semantics, empty lists, and boundary conditions
✅ **Safe References:** Proper null/length guards before iteration
✅ **Deferred Work Completion:** No deferred work exists for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task

### Compliance Statement

This implementation EXACTLY follows the Type 3 (Block Structure Skeleton) pattern as required by `executor.md`. The skeleton properly creates the delegation structure with comment placeholders for child arguments. The conditional logic correctly handles null/empty cases, and the array iteration pattern properly converts the Terraform list with MaxItems: 1 to the API array format. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
