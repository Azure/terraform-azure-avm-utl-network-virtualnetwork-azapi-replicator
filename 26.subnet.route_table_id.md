# Task #26 - subnet.route_table_id - Implementation Proof

## Summary

Implemented `subnet.route_table_id` as an optional field within the subnet block, mapping to Azure API's `routeTable.id` structure. The field accepts a Route Table resource ID and is conditionally set only when a non-empty value is provided.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name
          properties = merge(
            length(subnet.address_prefixes) == 1 ? {
              addressPrefix = subnet.address_prefixes[0]
            } : {
              addressPrefixes = subnet.address_prefixes
            },
            {
              defaultOutboundAccess                 = subnet.default_outbound_access_enabled
              privateEndpointNetworkPolicies        = subnet.private_endpoint_network_policies
              privateLinkServiceNetworkPolicies     = subnet.private_link_service_network_policies_enabled ? "Enabled" : "Disabled"
              routeTable = subnet.route_table_id != null && subnet.route_table_id != "" ? { # <-
                id = subnet.route_table_id                                                  # <-
              } : null                                                                      # <-
              # Other fields...
            }
          )
        }
      ] : null
    }
  }
}
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code(entrypoint_name="create")`

**Pattern:** Single-phase operation (one `CreateOrUpdateThenPoll`)

**Field Classification:** Create phase - processed during primary resource creation

**Go Code Evidence:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	if err != nil {
		return err
	}

	locks.MultipleByName(routeTables, routeTableResourceName)
	defer locks.UnlockMultipleByName(routeTables, routeTableResourceName)

	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,  // <- route_table_id processed here via expandVirtualNetworkProperties
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

**Decision:** Field is processed in the Create phase within `expandVirtualNetworkProperties` and included in the primary `CreateOrUpdateThenPoll` operation. No post-creation operations. Implemented in `local.body.properties.subnets[].properties.routeTable`.

## Assignment Path Verification

**Predicted Path:** `body.properties.subnets[].properties.routeTable.id`

**Go Code Evidence - expandVirtualNetworkProperties:**
```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	routeTables := make([]string, 0)
	if subs := d.Get("subnet").(*pluginsdk.Set); subs.Len() > 0 {
		for _, subnet := range subs.List() {
			subnet := subnet.(map[string]interface{})
			
			// ...
			subnetObj, err := getExistingSubnet(ctx, client, id, name)
			// ...
			
			if routeTableId := subnet["route_table_id"].(string); routeTableId != "" {
				id, err := routetables.ParseRouteTableID(routeTableId)
				if err != nil {
					return nil, nil, err
				}

				// Collecting a list of route tables to lock on outside of this function
				routeTables = append(routeTables, id.RouteTableName)
				subnetObj.Properties.RouteTable = &virtualnetworks.RouteTable{  // <- ASSIGNMENT
					Id: pointer.To(id.ID()),
				}
			}
			
			subnets = append(subnets, *subnetObj)
		}
	}

	properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
		// ...
		Subnets: &subnets,  // <- Subnets array assignment
	}
	
	return properties, &routeTables, nil  // <- Returns properties for vnet.Properties
}
```

**Assignment Trace:**
1. `subnet["route_table_id"]` → Retrieved from Terraform config
2. `subnetObj.Properties.RouteTable = &virtualnetworks.RouteTable{ Id: pointer.To(id.ID()) }` → Assigned to subnet's Properties.RouteTable
3. `subnets = append(subnets, *subnetObj)` → Subnet added to subnets array
4. `properties.Subnets = &subnets` → Subnets array assigned to properties
5. `vnet.Properties = vnetProperties` (in Create) → Properties assigned to VNet
6. SDK sends: `properties.subnets[].properties.routeTable.id`

**Verified Path:** `properties.subnets[].properties.routeTable.id`

**Path Comparison:** ✅ MATCH (predicted path matches verified path from Go code)

## Provider Schema

**Source:** `query_terraform_block_implementation_source_code(entrypoint_name="schema")`

**Go Code:**
```go
"subnet": {
	Type:       pluginsdk.TypeSet,
	Optional:   true,
	Computed:   true,
	ConfigMode: pluginsdk.SchemaConfigModeAttr,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			// ...
			"route_table_id": commonschema.ResourceIDReferenceOptional(&routetables.RouteTableId{}),
			// ...
		},
	},
},
```

**Field Properties:**
- **Type:** String
- **Required:** No (Optional)
- **Optional:** Yes
- **ForceNew:** No
- **Computed:** No
- **Default:** None
- **Validation:** `commonschema.ResourceIDReferenceOptional(&routetables.RouteTableId{})` (validates Route Table resource ID format)
- **DiffSuppressFunc:** None
- **CustomizeDiff:** None (verified in `resourceVirtualNetwork()` function - no CustomizeDiff defined)

## Azure API Schema

**API Version:** `2024-07-01`

**Query Method:** `query_azapi_resource_schema(path="body.properties.subnets.properties.routeTable")`

**Schema Type:**
```
ObjectWithOptionalAttrs(map[string]Type{"id":String, "location":String, "properties":ObjectWithOptionalAttrs(map[string]Type{"disableBgpRoutePropagation":Bool, "routes":List(...)}, [...]), "tags":Map(String)}, []string{"id", "location", "properties", "tags"})
```

**Property Path:** `body.properties.subnets[].properties.routeTable.id` (String, Optional)

**Note:** The Azure API accepts the full Route Table object structure, but the provider only sends the `id` field as a reference, which is the standard pattern for resource associations.

## Hidden Fields

**Query Method:** Analyzed `expandVirtualNetworkProperties` function

**Finding:** No hidden fields detected for `route_table_id`. The provider only sets the `id` field within the `routeTable` object based on user input. The Azure API may return additional fields like `location`, `properties`, `tags` when reading, but these are not managed by the provider for the inline subnet configuration.

**Note:** The `routeTables` array returned by `expandVirtualNetworkProperties` is used for locking (Task #2 already implemented this in `local.locks`), not as a hidden field in the body.

## Naming Convention

| Provider Field (snake_case) | Azure API Field (camelCase) | Notes |
|-----------------------------|----------------------------|-------|
| `route_table_id` | `routeTable.id` | Field name changes from snake_case to camelCase; provider sends only ID reference |

## Special Handling

### 1. No ForceNew Logic

**Schema Check:** `ForceNew: false` (not set)

**CustomizeDiff Check:** No CustomizeDiff defined in `resourceVirtualNetwork()`

**Conclusion:** Changes to `route_table_id` can be handled via updates. No entry needed in `replace_triggers_external_values`.

### 2. No Validation Logic

**Provider Validation:** The field uses `commonschema.ResourceIDReferenceOptional(&routetables.RouteTableId{})` which validates the resource ID format at the provider level.

**Replicator Validation:** Since `route_table_id` is defined as a plain `string` type in the existing `variables.tf`, and resource ID format validation is NOT a name format validation (per executor.md rules: "Skip ONLY Azure Resource ID format validations - these are verified by resource references"), we do NOT add validation to `variables.tf`.

**Rationale:** The Route Table resource ID format validation is a resource reference validation, not a value constraint validation. Users will reference an actual Route Table resource, and Terraform's dependency graph will ensure the ID is valid.

### 3. Conditional Assignment

**Implementation Logic:**
```hcl
routeTable = subnet.route_table_id != null && subnet.route_table_id != "" ? {
  id = subnet.route_table_id
} : null
```

**Rationale:**
- Check both `!= null` and `!= ""` to handle both null values and empty strings
- When null or empty, omit the `routeTable` object entirely (Azure API interprets this as "no route table association")
- When non-empty, create the `routeTable` object with only the `id` field (standard Azure resource reference pattern)
- With `ignore_null_property = true`, the null value is automatically filtered from the payload

### 4. No Sensitive Handling

**Schema Check:** No `Sensitive: true` flag in schema

**Conclusion:** Field value goes in `local.body`, not `local.sensitive_body`.

### 5. Update Phase Handling

**Go Code Evidence - resourceVirtualNetworkUpdate:**
```go
func resourceVirtualNetworkUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	if d.HasChange("subnet") {
		subnets, routeTables, err := expandVirtualNetworkSubnets(ctx, *client, d.Get("subnet").(*pluginsdk.Set).List(), *id)
		if err != nil {
			return fmt.Errorf("expanding `subnet`: %+v", err)
		}
		payload.Properties.Subnets = subnets

		locks.MultipleByName(routeTables, routeTableResourceName)
		defer locks.UnlockMultipleByName(routeTables, routeTableResourceName)
	}
	// ...
}
```

**Finding:** The Update method handles changes to the entire `subnet` block (including `route_table_id`) by re-expanding all subnets and replacing the subnets array. No special logic for `route_table_id` specifically.

**Conclusion:** The field is updatable. Changes are applied via the normal Update path.

## Deferred Work Completion

**Status:** N/A - No work was deferred TO this task in `following.md` (file does not exist).

## Critical Review & Edge Cases

### Null Semantics

**Case 1: `route_table_id = null`**
- Meaning: No route table association
- Implementation: `routeTable = null`
- Azure API behavior: No route table attached to subnet

**Case 2: `route_table_id = ""`**
- Meaning: Empty string (same as null - no association)
- Implementation: Condition `subnet.route_table_id != null && subnet.route_table_id != ""` ensures `routeTable = null`
- Azure API behavior: No route table attached to subnet

**Case 3: `route_table_id = "/subscriptions/.../routeTables/rt-name"`**
- Meaning: Associate this route table with the subnet
- Implementation: `routeTable = { id = route_table_id }`
- Azure API behavior: Route table attached to subnet

### Boundary Conditions

**Empty String Check:** The implementation checks both `!= null` and `!= ""` to handle the edge case where users might explicitly set an empty string. This prevents sending `routeTable = { id = "" }` which would be invalid.

**Object Structure:** The provider wraps the ID in an object `{ id: "..." }` rather than sending the ID directly. This matches Azure API expectations for resource references.

### Idempotency

**Consistent Structure:** The implementation always produces the same structure for the same input:
- `null` or `""` → `routeTable: null` (omitted with `ignore_null_property = true`)
- Valid ID → `routeTable: { id: "..." }`

**No Order Dependencies:** The field is a simple string reference; no collections or ordering involved.

### Safe References

**Null Safety:** The implementation safely checks `subnet.route_table_id != null` before accessing the string value. Since `route_table_id` is defined as `string` (not nullable) in the parent subnet object type in `variables.tf`, it will always be present (though potentially as an empty string or null in HCL semantics).

**Type Safety:** The field is accessed as `subnet.route_table_id` which is safe because:
1. We're inside a `for subnet in var.subnet` loop
2. The loop only executes when `var.subnet != null && length(var.subnet) > 0`
3. Each `subnet` is guaranteed to be an object with the defined schema

### Edge Case: Changing Route Table Association

**Scenario:** User changes from one route table to another (e.g., `route_table_id` changes from RT1 to RT2)

**Provider Behavior:** The provider processes this as a normal update:
1. Reads existing subnet configuration
2. Updates the `routeTable.id` field
3. Sends updated subnet array to Azure API

**Replicator Behavior:** Same - the new value flows through to `routeTable.id`, and AzAPI sends the update.

**Idempotency:** ✅ Applying the same configuration twice produces the same result.

### Edge Case: Removing Route Table Association

**Scenario:** User changes from `route_table_id = "/subscriptions/.../rt-name"` to `route_table_id = null`

**Provider Behavior:** The condition `if routeTableId := subnet["route_table_id"].(string); routeTableId != ""` evaluates to false, so `subnetObj.Properties.RouteTable` is not set (remains nil or null from `getExistingSubnet`).

**Replicator Behavior:** The condition `subnet.route_table_id != null && subnet.route_table_id != ""` evaluates to false, so `routeTable = null`, which is omitted from the payload with `ignore_null_property = true`.

**Azure API Behavior:** Receiving no `routeTable` field removes the association.

**Idempotency:** ✅ Removing the association multiple times has the same effect.

## Implementation Checklist

- ✅ Property in correct local (`local.body.properties.subnets[].properties.routeTable`)
- ✅ ForceNew wrapped: N/A (not ForceNew)
- ✅ All logic EXACTLY replicated from provider (conditional assignment, empty string check, object wrapping)
- ✅ Validations: N/A (Resource ID reference validation skipped per executor.md rules)
- ✅ TODO comment: N/A (not a sensitive field requiring migration)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: N/A (no deferrals made)
- ✅ Deferred work from following.md: N/A (no work deferred to this task)
- ✅ Critical review (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Proof created
- ✅ Track.md to be updated to "Pending for check"
- ✅ Self-Review: Only `route_table_id` implementation added; replaced comment placeholder; no other fields modified

## Self-Review Confirmation

**Did I add ONLY what this task requires?**
✅ YES - Only implemented `subnet.route_table_id` by replacing the comment placeholder with the routeTable assignment

**Did I add hidden fields that belong to other tasks?**
✅ NO - No hidden fields were added

**Did I add fields from other tasks?**
✅ NO - Only modified the specific line for `route_table_id`; other task placeholders remain unchanged

**Verification:**
- Reviewed `migrate_main.tf` changes
- Confirmed only the comment `# routeTable = ... # Task #26` was replaced
- No other fields or logic added
- All other task placeholders (#27, #28, #29, #31) remain intact

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #26 - subnet.route_table_id

### Validation Results

✅ **ForceNew Logic:** Not ForceNew (schema `ForceNew: false`). No CustomizeDiff found. No entry in `replace_triggers_external_values` required.
✅ **Stable Keys:** N/A (not ForceNew)
✅ **Phase Detection:** Field correctly placed in `local.body.properties.subnets[].properties.routeTable` (Create phase)
✅ **Type Conversion:** Correct conversion from `string` to Azure API `{ id: string }` object structure
✅ **Null Handling:** Correctly checks both `!= null` and `!= ""` to handle null and empty string cases
✅ **Provider Logic Replication:** Exactly matches provider's conditional logic:
  - Provider: `if routeTableId := subnet["route_table_id"].(string); routeTableId != "" { ... }`
  - Shadow: `subnet.route_table_id != null && subnet.route_table_id != "" ? { id = subnet.route_table_id } : null`
✅ **Validations:** None required (Resource ID format validation correctly skipped per executor.md rules)
✅ **Deferred Work Completion:** No deferred work for this task (no `following.md` exists)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled:
  - Null semantics correctly documented
  - Empty string check prevents invalid API payload
  - Object wrapping matches Azure API expectations
  - Changing/removing route table association handled correctly
✅ **Assignment Path Verification:** Complete trace through Go code confirms path `properties.subnets[].properties.routeTable.id` is correct
✅ **Locks Handling:** Route table locking already implemented in Task #2 via `expandVirtualNetworkProperties` return value

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The conditional logic matches the provider's empty string check, the object structure matches the Azure API expectations, and null handling is correct. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Checks:**
- ✅ Empty string check (`routeTableId != ""`) replicated as `subnet.route_table_id != null && subnet.route_table_id != ""`
- ✅ Object wrapping (`&virtualnetworks.RouteTable{ Id: pointer.To(id.ID()) }`) replicated as `{ id = subnet.route_table_id }`
- ✅ Conditional assignment (if block) replicated as ternary expression
- ✅ Null when empty replicated correctly
- ✅ No validation added (correctly skipped resource ID validation per executor.md)
- ✅ No ForceNew logic added (correctly identified as not ForceNew)

**Status:** APPROVED ✅

---
