# Task #32 - subnet.delegation.name

## Summary
Implemented the required argument `subnet.delegation.name` by replacing the comment placeholder in the delegation block skeleton. This field is a simple string identifier for the delegation and is directly assigned without transformation.

## Create Phase Verification

### Query Create Method
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
    if err != nil {
        return err
    }
    // ...
    vnet := virtualnetworks.VirtualNetwork{
        Name:             pointer.To(id.VirtualNetworkName),
        ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
        Location:         pointer.To(location.Normalize(d.Get("location").(string))),
        Properties:       vnetProperties,
        Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
    }
    // ...
    if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
        return fmt.Errorf("creating %s: %+v", id, err)
    }
    // ...
}
```

### Pattern Identification
**Single-phase operation**: The resource uses a single `CreateOrUpdateThenPoll` call. The delegation name is processed in `expandVirtualNetworkProperties` → `expandVirtualNetworkSubnetDelegation` before the primary create operation.

### Field Classification
The `delegation.name` field is part of the subnet delegation configuration, processed during the expand phase before the primary CreateOrUpdate call.

**Decision**: Field belongs in `local.body` (Create phase, included in primary CreateOrUpdate operation).

## Assignment Path Verification

### Predicted Path
`body.properties.subnets[].properties.delegations[].name`

### Go Code Evidence
From `expandVirtualNetworkSubnetDelegation`:
```go
func expandVirtualNetworkSubnetDelegation(input []interface{}) *[]virtualnetworks.Delegation {
    retDelegations := make([]virtualnetworks.Delegation, 0)

    for _, deleValue := range input {
        deleData := deleValue.(map[string]interface{})
        deleName := deleData["name"].(string)
        // ...

        retDelegation := virtualnetworks.Delegation{
            Name: &deleName,
            Properties: &virtualnetworks.ServiceDelegationPropertiesFormat{
                ServiceName: &srvName,
                Actions:     &retSrvActions,
            },
        }

        retDelegations = append(retDelegations, retDelegation)
    }

    return &retDelegations
}
```

Assignment chain:
1. Extract name from Terraform config: `deleName := deleData["name"].(string)`
2. Assign to Delegation struct: `Name: &deleName`
3. Return `*[]virtualnetworks.Delegation` from expand function
4. Called from `expandVirtualNetworkProperties`: `subnetObj.Properties.Delegations = expandVirtualNetworkSubnetDelegation(subnet["delegation"].([]interface{}))`
5. `subnetObj` is `virtualnetworks.Subnet`
6. Subnet added to `properties.Subnets` slice
7. `vnet.Properties = vnetProperties`
8. `vnet` becomes the request body

### Verified Path
`body.properties.subnets[].properties.delegations[].name`

### Path Comparison
**MATCH** ✅ - Predicted path matches verified path.

## Provider Schema

From `resourceVirtualNetworkSchema()`:
```go
"delegation": {
    Type:       pluginsdk.TypeList,
    Optional:   true,
    MaxItems:   1,
    ConfigMode: pluginsdk.SchemaConfigModeAttr,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "name": {
                Type:     pluginsdk.TypeString,
                Required: true,
            },
            // ...
        },
    },
},
```

**Key Properties:**
- **Type**: String (TypeString)
- **Required**: true
- **No Validation**: No ValidateFunc specified
- **No ForceNew**: Not marked as ForceNew
- **No DiffSuppressFunc**: No custom diff suppression

## Azure API Schema

From the API schema query, the delegations structure is:
```
delegations: List(ObjectWithOptionalAttrs(map[string]Type{
    "id":String, 
    "name":String, 
    "properties":ObjectWithOptionalAttrs(...)
    "type":String
}, []string{"id", "name", "properties", "type"}))
```

**API Structure:**
- `name` field is a required String in the delegation object
- Maps directly from Terraform to API without transformation

## Hidden Fields

No hidden fields for the `name` field. The expand function shows a direct assignment:
```go
retDelegation := virtualnetworks.Delegation{
    Name: &deleName,  // Direct assignment from Terraform config
    Properties: &virtualnetworks.ServiceDelegationPropertiesFormat{
        ServiceName: &srvName,
        Actions:     &retSrvActions,
    },
}
```

The `id` and `type` fields in the API schema are read-only (computed by the API) and not set by the provider.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `delegation.name` | `delegations[].name` | Direct string assignment |

## Special Handling

### No ForceNew
The field does not have `ForceNew: true` in the schema, and there is no CustomizeDiff logic for this field. Changes to delegation name can be updated in-place.

### No Validation
The provider schema has no ValidateFunc for this field. The field only requires a non-empty string (implicitly enforced by Required: true in Terraform).

### No Sensitive Data
This is a plain string identifier, not sensitive.

### Direct Assignment
The implementation directly assigns `delegation.name` to the API field without any transformation:
```hcl
name = delegation.name
```

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name
          properties = merge(
            # ... existing fields ...
            {
              delegations = subnet.delegation != null && length(subnet.delegation) > 0 ? [
                for delegation in subnet.delegation : {
                  name = delegation.name                                                 # <-
                  properties = {
                    serviceName = null # Task #34
                    actions     = null # Task #35
                  }
                }
              ] : null
            }
          )
        }
      ] : null
    }
  }
}
```

## Deferred Work Completion

Checked `following.md` - file does not exist. No deferred work for this task.

## Critical Review & Edge Cases

### Null Semantics
- **Required field**: In provider schema, `name` is Required: true within the delegation block
- **Parent block optional**: The delegation block itself is optional within subnet
- **When delegation exists**: The name must be provided (enforced by Terraform's Required validation)
- **Direct reference**: `delegation.name` is safe because we only iterate when `subnet.delegation != null && length(subnet.delegation) > 0`

### Edge Cases
1. **Empty string**: Provider schema has no explicit validation, but Terraform's Required: true ensures the field is provided by users
2. **MaxItems: 1**: Delegation is a list with MaxItems: 1, so only one delegation per subnet
3. **Name uniqueness**: Not enforced by the provider schema (could have same name across different subnets)
4. **Special characters**: No regex validation in provider schema - accepts any string value

### Idempotency
- **String comparison**: Direct string equality check in API updates
- **No transformation**: Value passes through unchanged, ensuring idempotent operations
- **Stable ordering**: Since MaxItems: 1, no array ordering concerns

### Safe References
- ✅ Access `delegation.name` is safe within the iteration over `subnet.delegation`
- ✅ Parent null checks prevent iteration when delegation is null/empty
- ✅ No nested object access beyond the direct field
- ✅ No conditional logic needed - field is always present when delegation block exists

### Boundary Conditions
- **No delegation block**: Entire `delegations` field is null (handled by parent skeleton)
- **Delegation without name**: Would be caught by Terraform validation (Required: true)
- **Long names**: No length restrictions in provider schema
- **Unicode/special chars**: No restrictions in provider schema

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew not applicable (field is not ForceNew)
- ✅ All logic exactly replicated from provider (direct string assignment)
- ✅ Validations: None required (Terraform enforces Required: true automatically)
- ✅ TODO comment: Not applicable (not a sensitive field)
- ✅ Hidden fields checked - none found
- ✅ Deferred work in following.md: Not applicable (no work deferred to other tasks)
- ✅ Deferred work from following.md: Checked - file does not exist
- ✅ Critical review completed
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ Self-Review: Implementation adds ONLY the delegation.name field as required by Task #32

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #32 - subnet.delegation.name

### Validation Results

✅ **Field Placement:** Correctly placed in `local.body.properties.subnets[].properties.delegations[].name` (line 89 in migrate_main.tf)
✅ **Assignment Path:** Matches provider's direct assignment pattern `Name: &deleName` → `name = delegation.name`
✅ **ForceNew Logic:** Not applicable - field is not ForceNew, no CustomizeDiff
✅ **Stable Keys:** Not applicable (no replace_triggers_external_values entry needed)
✅ **Phase Detection:** Correctly in Create phase (`local.body`)
✅ **Type Conversion:** Direct string to string, no conversion needed
✅ **Null Handling:** Properly handled with parent null checks in iteration condition
✅ **Validations:** None required - Required: true enforced by Terraform automatically
✅ **Sensitive Fields:** Not applicable (plain string identifier)
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** Not applicable (no work deferred to other tasks)
✅ **Edge Cases:** Thoroughly analyzed - null semantics, MaxItems:1 constraint, safe references

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field uses direct string assignment matching the provider's expand function logic. No deviations, simplifications, or "safer alternatives" were found.

**Provider Code:**
```go
deleName := deleData["name"].(string)
retDelegation := virtualnetworks.Delegation{
    Name: &deleName,
    // ...
}
```

**Shadow Implementation:**
```hcl
name = delegation.name
```

The implementation correctly:
- Assigns the field directly without transformation
- Handles null cases through parent iteration conditions
- Places the field in the correct location in the API structure
- Requires no additional validations beyond Terraform's Required enforcement
- Adds only the specific field required by Task #32

**Status:** APPROVED ✅

---

