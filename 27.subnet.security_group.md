# Task #27 - subnet.security_group - Implementation Proof

## Summary

Implemented `subnet.security_group` as an optional field within the subnet block, mapping to Azure API's `networkSecurityGroup.id` structure. The field accepts a Network Security Group resource ID and is conditionally set only when a non-empty value is provided.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name
          properties = merge(
            length(subnet.address_prefixes) == 1 ? {
              addressPrefix = subnet.address_prefixes[0]
            } : {
              addressPrefixes = subnet.address_prefixes
            },
            {
              defaultOutboundAccess                 = subnet.default_outbound_access_enabled
              privateEndpointNetworkPolicies        = subnet.private_endpoint_network_policies
              privateLinkServiceNetworkPolicies     = subnet.private_link_service_network_policies_enabled ? "Enabled" : "Disabled"
              routeTable = subnet.route_table_id != null && subnet.route_table_id != "" ? {
                id = subnet.route_table_id
              } : null
              networkSecurityGroup = subnet.security_group != null && subnet.security_group != "" ? { # <-
                id = subnet.security_group                                                             # <-
              } : null                                                                                 # <-
              # Other fields...
            }
          )
        }
      ] : null
    }
  }
}
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code(entrypoint_name="create")`

**Pattern:** Single-phase operation (one `CreateOrUpdateThenPoll`)

**Field Classification:** Create phase - processed during primary resource creation

**Go Code Evidence:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	if err != nil {
		return err
	}

	locks.MultipleByName(routeTables, routeTableResourceName)
	defer locks.UnlockMultipleByName(routeTables, routeTableResourceName)

	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,  // <- security_group processed here via expandVirtualNetworkProperties
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	
	// Lock NSGs to prevent concurrent modifications
	networkSecurityGroupNames := make([]string, 0)
	for _, subnet := range *vnet.Properties.Subnets {
		if subnet.Properties != nil && subnet.Properties.NetworkSecurityGroup != nil {
			parsedNsgID, err := networksecuritygroups.ParseNetworkSecurityGroupID(*subnet.Properties.NetworkSecurityGroup.Id)
			if err != nil {
				return err
			}
			networkSecurityGroupName := parsedNsgID.NetworkSecurityGroupName
			if !utils.SliceContainsValue(networkSecurityGroupNames, networkSecurityGroupName) {
				networkSecurityGroupNames = append(networkSecurityGroupNames, networkSecurityGroupName)
			}
		}
	}

	locks.MultipleByName(&networkSecurityGroupNames, networkSecurityGroupResourceName)
	defer locks.UnlockMultipleByName(&networkSecurityGroupNames, networkSecurityGroupResourceName)
	
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

**Decision:** Field is processed in the Create phase within `expandVirtualNetworkProperties` and included in the primary `CreateOrUpdateThenPoll` operation. No post-creation operations. Implemented in `local.body.properties.subnets[].properties.networkSecurityGroup`.

**Note on Locking:** The provider locks Network Security Groups during create/update operations. However, per executor.md instructions, locks are handled only in Type 2 tasks (`__check_root_hidden_fields__`). The lock logic for NSGs should have been identified in Task #11. Since we're in a Type 4 task (Block Argument), we do not add lock logic here.

## Assignment Path Verification

**Predicted Path:** `body.properties.subnets[].properties.networkSecurityGroup.id`

**Go Code Evidence - expandVirtualNetworkProperties:**
```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	routeTables := make([]string, 0)
	if subs := d.Get("subnet").(*pluginsdk.Set); subs.Len() > 0 {
		for _, subnet := range subs.List() {
			subnet := subnet.(map[string]interface{})
			
			// ...
			subnetObj, err := getExistingSubnet(ctx, client, id, name)
			// ...
			
			if secGroup := subnet["security_group"].(string); secGroup != "" {  // <- READ from Terraform config
				subnetObj.Properties.NetworkSecurityGroup = &virtualnetworks.NetworkSecurityGroup{  // <- ASSIGNMENT
					Id: &secGroup,
				}
			} else {
				subnetObj.Properties.NetworkSecurityGroup = nil  // <- Explicitly set to nil when empty
			}
			
			subnets = append(subnets, *subnetObj)
		}
	}

	properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
		// ...
		Subnets: &subnets,  // <- Subnets array assignment
	}
	
	return properties, &routeTables, nil  // <- Returns properties for vnet.Properties
}
```

**Assignment Trace:**
1. `subnet["security_group"]` → Retrieved from Terraform config
2. `subnetObj.Properties.NetworkSecurityGroup = &virtualnetworks.NetworkSecurityGroup{ Id: &secGroup }` → Assigned to subnet's Properties.NetworkSecurityGroup
3. `subnets = append(subnets, *subnetObj)` → Subnet added to subnets array
4. `properties.Subnets = &subnets` → Subnets array assigned to properties
5. `vnet.Properties = vnetProperties` (in Create) → Properties assigned to VNet
6. SDK sends: `properties.subnets[].properties.networkSecurityGroup.id`

**Verified Path:** `properties.subnets[].properties.networkSecurityGroup.id`

**Path Comparison:** ✅ MATCH (predicted path matches verified path from Go code)

## Provider Schema

**Source:** `query_golang_source_code(symbol="func", name="resourceVirtualNetworkSchema")`

**Go Code:**
```go
"subnet": {
	Type:       pluginsdk.TypeSet,
	Optional:   true,
	Computed:   true,
	ConfigMode: pluginsdk.SchemaConfigModeAttr,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			// ...
			"security_group": {
				Type:     pluginsdk.TypeString,
				Optional: true,
			},
			// ...
		},
	},
},
```

**Key Details:**
- **Type:** `TypeString`
- **Optional:** `true`
- **Default:** None (no default value specified)
- **ValidateFunc:** None (no validation function specified)
- **ForceNew:** Not present
- **Sensitive:** `false`
- **Computed:** `false`

**Empty String Handling:** The provider explicitly checks for empty string (`secGroup != ""`) and sets `NetworkSecurityGroup` to `nil` when the value is empty. This matches the same pattern used for `route_table_id`.

## Azure API Schema

**Property Path:** `properties.subnets[].properties.networkSecurityGroup.id`

**Query Result:**
```
query_azapi_resource_schema(
  resource_type="Microsoft.Network/virtualNetworks",
  api_version="2024-07-01",
  path="body.properties.subnets.properties.networkSecurityGroup"
)
```

**Schema Type:**
```
ObjectWithOptionalAttrs(map[string]Type{
  "id": String,
  "location": String,
  "properties": ObjectWithOptionalAttrs(map[string]Type{
    "flushConnection": Bool,
    "securityRules": List(...)
  }, [...]),
  "tags": Map(String)
}, [...])
```

The Azure API expects a `networkSecurityGroup` object with an `id` field (and optionally other fields like `location`, `properties`, `tags`). The provider only sets the `id` field, which is sufficient for associating an existing NSG with the subnet.

## Hidden Fields

None. The field is directly exposed in the Terraform schema with no hidden transformations or additional logic applied. The provider uses a simple assignment pattern: if the value is non-empty, create the NSG reference object; otherwise, set to `nil`.

## Mapping

| Terraform Field | Azure API Field |
|----------------|-----------------|
| `subnet.security_group` | `properties.subnets[].properties.networkSecurityGroup.id` |

**Naming Convention:** 
- Terraform: `security_group` (snake_case)
- Azure API: `networkSecurityGroup` (camelCase)

## Special Handling

### Validation

**Implementation:** None required.

**Rationale:** The provider schema does not include any `ValidateFunc` for the `security_group` field. Unlike `route_table_id` which uses `commonschema.ResourceIDReferenceOptional(&routetables.RouteTableId{})` (which includes ID format validation), `security_group` is defined as a plain optional string with no validation. Therefore, no validation needs to be replicated in `variables.tf`.

**Note:** The field accepts a Network Security Group resource ID string. While the provider parses this ID for locking purposes (using `networksecuritygroups.ParseNetworkSecurityGroupID`), parsing failures only occur during the lock phase, not as a validation step. Per executor.md, we skip Azure Resource ID format validations as they are verified by resource references.

### Default Value

**Implementation:** None required.

**Rationale:** The provider schema does not specify a `Default` value for this field. The field is purely optional, and when not provided (or empty string), the provider explicitly sets `NetworkSecurityGroup` to `nil`. This is already handled in our implementation by the conditional check:
```hcl
networkSecurityGroup = subnet.security_group != null && subnet.security_group != "" ? {
  id = subnet.security_group
} : null
```

### ForceNew Handling

**Implementation:** None required.

**Rationale:** The schema does not include `ForceNew: true`, and no `CustomizeDiff` logic was found in the resource function. The Update method in `expandVirtualNetworkSubnets` uses identical logic to the Create method:

```go
// In expandVirtualNetworkSubnets (used by Update)
if secGroup := subnet["security_group"].(string); secGroup != "" {
    subnetObj.Properties.NetworkSecurityGroup = &virtualnetworks.NetworkSecurityGroup{
        Id: &secGroup,
    }
} else {
    subnetObj.Properties.NetworkSecurityGroup = nil
}
```

This confirms the field is fully updateable in-place. No entry needed in `replace_triggers_external_values`.

### Empty String Handling

**Implementation Pattern:** The provider treats empty string the same as `nil`:

```go
if secGroup := subnet["security_group"].(string); secGroup != "" {
    // Set NSG reference
} else {
    // Explicitly set to nil (disassociate NSG)
}
```

**Replication:** Our implementation follows the exact same pattern by checking both `!= null` and `!= ""`:

```hcl
networkSecurityGroup = subnet.security_group != null && subnet.security_group != "" ? {
  id = subnet.security_group
} : null
```

This ensures that:
- `null` → `networkSecurityGroup` = `null`
- `""` → `networkSecurityGroup` = `null`
- `"<valid-id>"` → `networkSecurityGroup` = `{ id = "<valid-id>" }`

## Deferred Work Completion

Checked `following.md` - file does not exist. No work was deferred to this task.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics:**
- `subnet.security_group = null` → `networkSecurityGroup` not set (ignored by `ignore_null_property`)
- `subnet.security_group = ""` → `networkSecurityGroup = null` (explicit removal)
- Matches provider behavior: empty string explicitly sets field to `nil`

**2. Empty String vs Null:**
The implementation correctly distinguishes between `null` (field not specified) and `""` (field explicitly set to empty):
- Both result in `networkSecurityGroup = null` in the API payload
- With `ignore_null_property = true`, `null` values are automatically filtered out
- The explicit check `subnet.security_group != ""` ensures empty strings are treated as removal requests

**3. Resource ID Format:**
- The field accepts any string value (no validation in schema)
- Provider parses the ID during lock acquisition, but parsing errors are not validation errors
- Users are responsible for providing valid NSG resource IDs
- Matches provider behavior: no upfront validation, errors occur at API call time if ID is invalid

**4. Boundary Conditions:**
- Single subnet with NSG: ✅ Works
- Multiple subnets, some with NSGs: ✅ Works (list comprehension handles each subnet independently)
- No subnets: ✅ No issue (`var.subnet` can be `null` or empty list)
- NSG ID change: ✅ Update in-place (no ForceNew)
- NSG removal (`""` → `null`): ✅ Explicit `null` assignment disassociates NSG

**5. Idempotency:**
- Same value applied twice: ✅ Idempotent (API accepts same NSG ID without changes)
- Order independence: ✅ (NSG association is per-subnet, not order-dependent)
- With `ignore_null_property = true`: ✅ Null values filtered automatically

**6. Safe References:**
- `subnet.security_group` is accessed within the subnet loop where `subnet` is guaranteed to exist
- Conditional checks `!= null && != ""` prevent issues with undefined values
- No nested property access beyond the string value itself

**7. Interaction with Other Fields:**
- No conflicts with other subnet fields (delegations, service endpoints, etc.)
- Independent from `route_table_id` (can have both, either, or neither)
- Locking is handled at resource level (Task #11), not here

**8. Update Behavior:**
- Adding NSG to existing subnet: ✅ Update in-place
- Removing NSG from subnet: ✅ Update in-place (set to `null`)
- Changing NSG ID: ✅ Update in-place (no recreation)
- Matches provider Update method logic exactly

## Checklist

- ✅ Property in correct local (`body.properties.subnets[].properties.networkSecurityGroup`)
- ✅ ForceNew wrapped: N/A (field is not ForceNew)
- ✅ ALL logic EXACTLY replicated from provider (empty string handling, conditional assignment)
- ✅ Validations IMPLEMENTED in variables.tf: N/A (no validations in provider schema)
- ✅ TODO comment added to original field: N/A (not a sensitive field)
- ✅ Hidden fields checked: None found
- ✅ Deferred work in following.md: N/A (not deferring any work)
- ✅ Deferred work from following.md: None (file doesn't exist)
- ✅ Critical review (null, edge, idempotent, safe refs): Completed above
- ✅ Edge Case Analysis in proof: Completed above
- ✅ Proof created: This document
- ✅ `track.md` updated to Pending for check: Will update next
- ✅ Self-Review: Only implemented `subnet.security_group` field as required by Task #27

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #27 - subnet.security_group

### Validation Results

✅ **ForceNew Logic:** Not ForceNew - field is fully updateable in-place (verified in both Create and Update methods)
✅ **Stable Keys:** N/A - field is not in replace_triggers_external_values (correctly not ForceNew)
✅ **Phase Detection:** Field correctly placed in Create phase within `local.body.properties.subnets[].properties.networkSecurityGroup`
✅ **Type Conversion:** String value correctly converted to object structure `{ id = value }` matching Azure API schema
✅ **Null Handling:** Correctly handles both `null` and empty string `""` - both result in `networkSecurityGroup = null` (exact provider behavior)
✅ **Empty String Handling:** Correctly checks `subnet.security_group != null && subnet.security_group != ""` matching provider's explicit empty string check
✅ **Validations:** None required - provider schema has no ValidateFunc (correctly documented, no Azure Resource ID format validation needed per executor.md)
✅ **Locks:** Correctly noted that NSG locks are handled in Task #11 (Type 2), not in this Type 4 task (per executor.md guidelines)
✅ **Deferred Work Completion:** No deferred work for this task (following.md doesn't exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive edge case analysis covering null semantics, empty string vs null, boundary conditions, idempotency, and update behavior
✅ **Assignment Path:** Correctly traced through expandVirtualNetworkProperties to verified path `properties.subnets[].properties.networkSecurityGroup.id`

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The empty string handling logic matches the provider's explicit check (`secGroup != ""`), the field is correctly placed in the Create phase, no validations are needed per provider schema, and the field is correctly identified as updateable (not ForceNew). No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
