# Task #22: subnet.address_prefixes - Block Argument

## Summary
Implemented the `address_prefixes` argument within the `subnet` block for `azurerm_virtual_network`, mapping to Azure API's `properties.subnets[].properties.addressPrefix` (singular) or `addressPrefixes` (plural) based on array length. This field is Required and must contain at least one CIDR prefix. The provider uses a special logic: if only 1 prefix exists, it sets `addressPrefix` (singular); otherwise it sets `addressPrefixes` (plural).

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [  # <-
        for subnet in var.subnet : {  # <-
          name = subnet.name  # <-
          properties = merge(  # <-
            length(subnet.address_prefixes) == 1 ? {  # <-
              addressPrefix = subnet.address_prefixes[0]  # <-
            } : {  # <-
              addressPrefixes = subnet.address_prefixes  # <-
            },  # <-
            {  # <-
              # Other fields...  # <-
            }  # <-
          )  # <-
        }  # <-
      ] : null  # <-
    }
  }
}
```

**Validation in variables.tf:**
```hcl
variable "subnet" {
  # ...
  validation {  # <-
    condition = var.subnet == null || alltrue([  # <-
      for s in var.subnet : s.address_prefixes != null && length(s.address_prefixes) >= 1  # <-
    ])  # <-
    error_message = "Each subnet's address_prefixes must contain at least one element."  # <-
  }  # <-

  validation {  # <-
    condition = var.subnet == null || alltrue([  # <-
      for s in var.subnet : alltrue([  # <-
        for prefix in s.address_prefixes : prefix != null && prefix != ""  # <-
      ])  # <-
    ])  # <-
    error_message = "Each address prefix in subnet.address_prefixes must not be null or empty."  # <-
  }  # <-
}
```

## Create Phase Verification

### Pattern Identification

**Go Code Evidence from `resourceVirtualNetworkCreate`:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	if err != nil {
		return err
	}

	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,  // <-- Properties including subnets with addressPrefixes
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	// ... additional setup ...

	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	
	// ... post-creation waiter ...
}
```

**Decision:** Single-phase creation. The `subnet.address_prefixes` field is processed during the primary `CreateOrUpdateThenPoll` operation as part of the virtual network properties. No post-creation operations for this field.

**Classification:** Create phase - `address_prefixes` goes in `local.body.properties.subnets[].properties.addressPrefix` or `addressPrefixes`

## Assignment Path Verification

### Predicted Path
`body.properties.subnets[].properties.addressPrefix` (singular) OR `body.properties.subnets[].properties.addressPrefixes` (plural)

### Go Code Evidence

From `expandVirtualNetworkProperties`:
```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	routeTables := make([]string, 0)
	if subs := d.Get("subnet").(*pluginsdk.Set); subs.Len() > 0 {
		for _, subnet := range subs.List() {
			subnet := subnet.(map[string]interface{})
			name := subnet["name"].(string)
			
			// Get existing subnet properties (if any)
			subnetObj, err := getExistingSubnet(ctx, client, id, name)
			if err != nil {
				return nil, nil, err
			}
			
			// Set the props from config
			subnetObj.Name = pointer.To(name)
			if subnetObj.Properties == nil {
				subnetObj.Properties = &virtualnetworks.SubnetPropertiesFormat{}
			}
			
			// CRITICAL: address_prefixes expansion logic
			addressPrefixes := make([]string, 0)
			for _, prefix := range subnet["address_prefixes"].([]interface{}) {
				addressPrefixes = append(addressPrefixes, prefix.(string))
			}

			// Provider logic: singular vs plural based on count
			if len(addressPrefixes) == 1 {
				subnetObj.Properties.AddressPrefix = pointer.To(addressPrefixes[0])  // <-- Singular
			} else {
				subnetObj.Properties.AddressPrefixes = pointer.To(addressPrefixes)  // <-- Plural
			}
			
			// ... other subnet properties ...
			
			subnets = append(subnets, *subnetObj)
		}
	}

	properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
		// ... other properties ...
		Subnets: &subnets,  // <-- Subnets assigned to Properties.Subnets
	}
	
	return properties, &routeTables, nil
}
```

From `resourceVirtualNetworkCreate`:
```go
vnet := virtualnetworks.VirtualNetwork{
	Properties: vnetProperties,  // <-- Properties (including Subnets with addressPrefixes) assigned here
}
```

**Traced Assignments:**
1. `expandVirtualNetworkProperties` reads `subnet["address_prefixes"]` and converts to Go slice
2. **CRITICAL**: If `len(addressPrefixes) == 1`, sets `SubnetPropertiesFormat.AddressPrefix` (singular)
3. **CRITICAL**: Otherwise, sets `SubnetPropertiesFormat.AddressPrefixes` (plural)
4. Subnet object added to `VirtualNetworkPropertiesFormat.Subnets`
5. `resourceVirtualNetworkCreate` assigns to `vnet.Properties`
6. Final structure: `VirtualNetwork.Properties.Subnets[].Properties.AddressPrefix` OR `AddressPrefixes`

### Verified Path
- **Single prefix**: `body.properties.subnets[].properties.addressPrefix` (singular)
- **Multiple prefixes**: `body.properties.subnets[].properties.addressPrefixes` (plural)

**Path Comparison:** ✅ MATCH - Implementation correctly replicates provider's singular/plural logic

## Provider Schema

**Field:** `subnet.address_prefixes`

**Go Schema Definition:**
```go
"subnet": {
	Type:       pluginsdk.TypeSet,
	Optional:   true,
	Computed:   true,
	ConfigMode: pluginsdk.SchemaConfigModeAttr,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"address_prefixes": {
				Type:     pluginsdk.TypeList,   // <-- List of strings
				Required: true,                  // <-- Required
				MinItems: 1,                     // <-- At least 1 item required
				Elem: &pluginsdk.Schema{
					Type:         pluginsdk.TypeString,
					ValidateFunc: validation.StringIsNotEmpty,  // <-- Each string must not be empty
				},
			},
			// ... other fields ...
		},
	},
},
```

**Key Attributes:**
- Type: `TypeList` (list of strings)
- Required: true
- MinItems: 1 (must have at least one address prefix)
- Elem validation: `StringIsNotEmpty` (each prefix must not be empty)
- No ForceNew: false (can be updated)
- No DiffSuppressFunc
- No CustomizeDiff
- No Default value

## Azure API Schema

**Property Path:** `body.properties.subnets[].properties.addressPrefix` (singular) OR `body.properties.subnets[].properties.addressPrefixes` (plural)

**API Schema Type (from query):**
```
"addressPrefix":String,
"addressPrefixes":List(String),
```

**Structure:** 
- Azure API accepts BOTH `addressPrefix` (singular string) AND `addressPrefixes` (plural list)
- Provider uses conditional logic: 1 prefix → singular field, 2+ prefixes → plural field
- Both fields are optional in the API schema (marked with `[]string{"addressPrefix", "addressPrefixes", ...}`)

## Hidden Fields Check

**No hidden fields detected.** The expand function only sets values from the user-provided configuration:

**Go Code Evidence:**
```go
addressPrefixes := make([]string, 0)
for _, prefix := range subnet["address_prefixes"].([]interface{}) {
	addressPrefixes = append(addressPrefixes, prefix.(string))
}

if len(addressPrefixes) == 1 {
	subnetObj.Properties.AddressPrefix = pointer.To(addressPrefixes[0])
} else {
	subnetObj.Properties.AddressPrefixes = pointer.To(addressPrefixes)
}
```

**Finding:** All values come directly from the `address_prefixes` input. No hardcoded or computed values are injected.

## Naming Convention

**Provider Field:** `address_prefixes` (snake_case, plural)  
**Azure API Field:** `addressPrefix` (camelCase, singular) OR `addressPrefixes` (camelCase, plural)

**Conversion:** Conditional based on array length

## Special Handling

### Required Field with Validation

**Schema Requirements:**
- Required: true
- MinItems: 1
- Each element: StringIsNotEmpty

**Validation Implementation:**
All validations replicated in `variables.tf`:

1. **MinItems: 1** → Validation checks `length(s.address_prefixes) >= 1`
2. **StringIsNotEmpty** → Validation checks each prefix is not null or empty string

```hcl
validation {
  condition = var.subnet == null || alltrue([
    for s in var.subnet : s.address_prefixes != null && length(s.address_prefixes) >= 1
  ])
  error_message = "Each subnet's address_prefixes must contain at least one element."
}

validation {
  condition = var.subnet == null || alltrue([
    for s in var.subnet : alltrue([
      for prefix in s.address_prefixes : prefix != null && prefix != ""
    ])
  ])
  error_message = "Each address prefix in subnet.address_prefixes must not be null or empty."
}
```

### Singular vs Plural Azure API Fields

**CRITICAL Provider Behavior:**

The provider uses conditional logic based on array length:

```go
if len(addressPrefixes) == 1 {
	subnetObj.Properties.AddressPrefix = pointer.To(addressPrefixes[0])  // Singular
} else {
	subnetObj.Properties.AddressPrefixes = pointer.To(addressPrefixes)  // Plural
}
```

**Replicator Implementation:**

```hcl
properties = merge(
  length(subnet.address_prefixes) == 1 ? {
    addressPrefix = subnet.address_prefixes[0]
  } : {
    addressPrefixes = subnet.address_prefixes
  },
  {
    # Other fields...
  }
)
```

**Rationale:**
- Uses `merge()` to conditionally add either `addressPrefix` or `addressPrefixes` to properties object
- When length is 1: sets `addressPrefix` with the single string value
- When length > 1: sets `addressPrefixes` with the full array
- Other subnet properties are merged in separate object (prepared for future tasks)
- EXACTLY replicates provider's conditional field selection logic

### No ForceNew Logic

The `address_prefixes` field has no `ForceNew: true` in schema and no CustomizeDiff logic. Changes to address prefixes can be handled via updates (confirmed in Update method).

**Go Code Evidence from `resourceVirtualNetworkUpdate`:**
```go
if d.HasChange("subnet") {
	subnets, routeTables, err := expandVirtualNetworkSubnets(ctx, *client, d.Get("subnet").(*pluginsdk.Set).List(), *id)
	if err != nil {
		return fmt.Errorf("expanding `subnet`: %+v", err)
	}
	payload.Properties.Subnets = subnets
	// ... continues with update ...
}
```

**Result:** No ForceNew trigger needed for `address_prefixes` changes.

## Deferred Work Completion

**Status:** N/A - No work was deferred TO this task in `following.md` (file does not exist).

## Critical Review & Edge Cases

### Null Semantics

- **`subnet.address_prefixes = null`:** Not allowed - field is Required with validation that checks `!= null && length >= 1`
- **`subnet.address_prefixes = []`:** Not allowed - MinItems: 1 validation prevents empty list
- **Single prefix `["10.0.0.0/24"]`:** Sets `addressPrefix = "10.0.0.0/24"` (singular)
- **Multiple prefixes `["10.0.0.0/24", "10.1.0.0/24"]`:** Sets `addressPrefixes = ["10.0.0.0/24", "10.1.0.0/24"]` (plural)

### Boundary Conditions

- **Exactly 1 prefix:** Correctly handled by conditional - uses singular field `addressPrefix`
- **Exactly 2 prefixes:** Correctly handled by conditional - uses plural field `addressPrefixes`
- **Many prefixes:** Handled by plural field, no upper limit in schema
- **Empty string prefix:** Prevented by validation checking `prefix != ""`
- **Null prefix in array:** Prevented by validation checking `prefix != null`

### Idempotency

- Array order is preserved by Terraform list type
- Conditional logic is deterministic based on array length
- No order-dependent operations within the implementation
- Azure API accepts both `addressPrefix` and `addressPrefixes` fields without conflicts

### Safe References

- Check `var.subnet != null` before iterating (parent block check)
- Check `length(var.subnet) > 0` before creating subnets array
- Access `subnet.address_prefixes` is safe within loop (subnet is guaranteed to be object from set)
- Access `subnet.address_prefixes[0]` is safe when `length(subnet.address_prefixes) == 1` (guaranteed by validation MinItems: 1)
- Validation ensures `address_prefixes` is never null and always has at least 1 element

### Edge Case Analysis

**1. Transition between singular and plural:**
- **Scenario:** User changes from 1 prefix to 2 prefixes (or vice versa)
- **Behavior:** Azure API handles this correctly - sending `addressPrefixes` when previously had `addressPrefix` works
- **Risk:** None - Azure API accepts both fields

**2. Subnet without address_prefixes:**
- **Prevention:** Required: true in schema + validation prevents null/empty
- **User Experience:** Clear error message at plan time

**3. Mixed null and valid prefixes:**
- **Prevention:** Validation checks each individual prefix for null/empty
- **User Experience:** Clear error message identifying the invalid prefix

**4. Validation order:**
- First validation: Checks array exists and has MinItems: 1
- Second validation: Checks each element is not null or empty
- Order ensures we don't try to iterate null array

**5. API field selection logic:**
- Implementation EXACTLY matches provider's `if len == 1` conditional
- Uses `merge()` to ensure only one field is set (never both)
- No possibility of sending both `addressPrefix` and `addressPrefixes` simultaneously

## Implementation Checklist

- ✅ Property in correct local (`local.body.properties.subnets[].properties`)
- ✅ ForceNew logic not needed (field is not ForceNew)
- ✅ Conditional singular/plural logic EXACTLY replicated from provider
- ✅ ALL validations IMPLEMENTED in variables.tf (Required, MinItems: 1, StringIsNotEmpty)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: N/A (no deferrals made)
- ✅ Deferred work from following.md: N/A (no work deferred to this task)
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis completed
- ✅ Proof document created
- ✅ Track.md ready to update to "Pending for check"
- ✅ Self-review: Only `address_prefixes` field implemented, no other subnet fields

## Self-Review Confirmation

**Did I add ONLY what this task requires?**  
✅ YES - Only the `address_prefixes` field implementation within the existing subnet block structure

**Did I add hidden fields that belong to other tasks?**  
✅ NO - No hidden fields detected for this specific field

**Did I add fields from other tasks?**  
✅ NO - Only `address_prefixes` was implemented, all other subnet fields remain as comment placeholders

**Verification:**
- Reviewed `migrate_main.tf` changes: Only added conditional singular/plural logic for address_prefixes
- Reviewed `variables.tf` changes: Only added validations for address_prefixes (MinItems, StringIsNotEmpty)
- Confirmed no other subnet properties were implemented
- Confirmed structure remains compatible with other pending tasks (#23-35)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #22 - subnet.address_prefixes

### Validation Results

✅ **ForceNew Logic:** Not applicable - field is not ForceNew (correctly identified)
✅ **Stable Keys:** All keys in `replace_triggers_external_values` and `body` are stable
✅ **Phase Detection:** Field correctly placed in `local.body.properties.subnets[].properties`
✅ **Type Conversion:** Correct conversion from Terraform `list(string)` to Azure API `addressPrefix` (singular string) OR `addressPrefixes` (plural list) based on array length
✅ **Null Handling:** Correctly leverages `ignore_null_property = true` for null semantics
✅ **Validations:** All provider validations implemented in `variables.tf`:
  - Required field with MinItems: 1 validation
  - StringIsNotEmpty validation for each prefix element
✅ **Conditional Logic:** EXACTLY replicates provider's singular/plural field logic:
  - `len(addressPrefixes) == 1` → sets `addressPrefix` (singular)
  - `len(addressPrefixes) > 1` → sets `addressPrefixes` (plural)
✅ **Merge Pattern:** Correct use of `merge()` - no shared path collision (addressPrefix vs addressPrefixes are mutually exclusive)
✅ **AzAPI 2.0+ Compliance:** No JSON encoding/decoding, correct use of `data.azapi_resource.existing.exists`
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled in proof document

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The conditional logic for singular vs plural Azure API fields matches the Go code precisely. All validations are implemented in `variables.tf`. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
