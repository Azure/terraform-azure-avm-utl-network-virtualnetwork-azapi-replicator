# Task #7 - edge_zone - Proof Document

## Summary
The `edge_zone` argument specifies the Edge Zone within the Azure Region where the Virtual Network should exist. It's ForceNew, normalized (lowercase, spaces removed), and maps to `extendedLocation.name` and `extendedLocation.type` in the Azure API.

## Shadow Implementation
```hcl
# In variables.tf
variable "edge_zone" {
  type        = string
  default     = null
  description = "(Optional) Specifies the Edge Zone within the Azure Region where this Virtual Network should exist. Changing this forces a new Virtual Network to be created."
  
  validation {
    condition     = var.edge_zone == null || length(var.edge_zone) > 0  # <-
    error_message = "The edge_zone must not be empty when specified."  # <-
  }
}

# In migrate_main.tf
locals {
  # Edge zone normalization (matches edgezones.Normalize which uses location.Normalize)
  normalized_edge_zone = var.edge_zone != null ? lower(replace(var.edge_zone, " ", "")) : null  # <-
  
  replace_triggers_external_values = {
    edge_zone = { value = local.normalized_edge_zone }  # <-
  }
  
  body = { 
    extendedLocation = local.normalized_edge_zone != null ? {  # <-
      name = local.normalized_edge_zone  # <-
      type = "EdgeZone"  # <-
    } : null  # <-
    properties = {
      # ...
    }
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase (one `CreateOrUpdateThenPoll`)

**Query Result - Create Method:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	
	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),  // <-- edge_zone assigned here
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	
	// ...
	
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

**Classification:** Create phase - field is assigned before primary `CreateOrUpdateThenPoll` operation.

**Decision:** Add to `local.body.extendedLocation` (not properties, it's a root-level API field).

## Assignment Path Verification

**Predicted Path:** `body.extendedLocation.name` and `body.extendedLocation.type`

**Go Code Evidence:**
```go
// From Create method:
vnet := virtualnetworks.VirtualNetwork{
	ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),  // Assigned to root-level field
	// ...
}

// expandEdgeZoneModel function:
func expandEdgeZoneModel(input string) *edgezones.Model {
	normalized := edgezones.Normalize(input)
	if normalized == "" {
		return nil
	}
	return &edgezones.Model{
		Name: normalized,
	}
}

// edgezones.Model structure:
type Model struct {
	Name string
}
```

The Go SDK's `ExtendedLocation` field is assigned directly to the `VirtualNetwork` struct (not inside `Properties`). The Azure API schema confirms this maps to `body.extendedLocation.name` and `body.extendedLocation.type`.

**Traced Path:**
1. `d.Get("edge_zone")` → input string
2. `expandEdgeZoneModel(input)` → `&edgezones.Model{Name: normalized}` or `nil`
3. Assigned to `vnet.ExtendedLocation` (root level, not in Properties)
4. Azure API receives as `extendedLocation.name` and `extendedLocation.type`

**Verified Path:** `body.extendedLocation.name` and `body.extendedLocation.type`

**Path Comparison:** ✅ Match - predicted path matches verified path.

## Provider Schema

**Source:** `github.com/hashicorp/terraform-provider-azurerm/internal/services/network`

```go
func resourceVirtualNetworkSchema() map[string]*pluginsdk.Schema {
	return map[string]*pluginsdk.Schema{
		// ...
		"edge_zone": commonschema.EdgeZoneOptionalForceNew(),
		// ...
	}
}

// commonschema.EdgeZoneOptionalForceNew:
func EdgeZoneOptionalForceNew() *schema.Schema {
	return &schema.Schema{
		Type:             schema.TypeString,
		Optional:         true,
		ForceNew:         true,
		ValidateFunc:     validation.StringIsNotEmpty,
		StateFunc:        edgezones.StateFunc,
		DiffSuppressFunc: edgezones.DiffSuppressFunc,
	}
}

// edgezones.StateFunc:
func StateFunc(location interface{}) string {
	input := location.(string)
	return Normalize(input)
}

// edgezones.DiffSuppressFunc:
func DiffSuppressFunc(_, old, new string, _ *schema.ResourceData) bool {
	return Normalize(old) == Normalize(new)
}

// edgezones.Normalize (uses location.Normalize):
func Normalize(input string) string {
	return location.Normalize(input)
}

// location.Normalize implementation:
func Normalize(input string) string {
	return strings.ToLower(strings.ReplaceAll(input, " ", ""))
}
```

**Key Properties:**
- **Type:** String
- **Optional:** true
- **ForceNew:** true
- **Validation:** `StringIsNotEmpty` - rejects empty strings
- **StateFunc:** Normalizes the value (lowercase, removes spaces)
- **DiffSuppressFunc:** Suppresses diff when normalized values match

## Azure API Schema

**Query Result:**
```
body.extendedLocation.name: "The name of the extended location."
body.extendedLocation.type: "The type of the extended location. (Possible values: EdgeZone)"
```

**Property Path:** `body.extendedLocation.name` and `body.extendedLocation.type`

**Type:** Both are strings. The `type` field must be set to `"EdgeZone"` when `extendedLocation` is present.

## Hidden Fields

**Check:** None. The `extendedLocation.type` field is hardcoded to `"EdgeZone"` by the provider, not exposed as a separate argument.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `edge_zone` | `extendedLocation.name` | Normalized (lowercase, spaces removed) |
| N/A (hardcoded) | `extendedLocation.type` | Always set to `"EdgeZone"` |

## Special Handling

### 1. Normalization (StateFunc)

**Provider Logic:**
```go
StateFunc: edgezones.StateFunc

func StateFunc(location interface{}) string {
	input := location.(string)
	return Normalize(input)
}

func Normalize(input string) string {
	return location.Normalize(input)  // lowercase + remove spaces
}
```

**Implementation:**
```hcl
locals {
  normalized_edge_zone = var.edge_zone != null ? lower(replace(var.edge_zone, " ", "")) : null
}
```

This ensures the value is stored in state in normalized form, matching provider behavior.

### 2. DiffSuppressFunc

**Provider Logic:**
```go
DiffSuppressFunc: edgezones.DiffSuppressFunc

func DiffSuppressFunc(_, old, new string, _ *schema.ResourceData) bool {
	return Normalize(old) == Normalize(new)
}
```

**Implementation:** By normalizing the value in locals and using it consistently, we achieve the same diff suppression behavior. The normalized value is used both in `replace_triggers_external_values` (for ForceNew detection) and in `body` (for API calls).

**Result:** If user changes `"West US"` to `"westus"` or `"west us"`, no replacement is triggered because the normalized value remains `"westus"`.

### 3. Validation

**Provider Validation:**
```go
ValidateFunc: validation.StringIsNotEmpty
```

**Implementation:**
```hcl
validation {
  condition     = var.edge_zone == null || length(var.edge_zone) > 0
  error_message = "The edge_zone must not be empty when specified."
}
```

This replicates the `StringIsNotEmpty` validation exactly.

### 4. ForceNew

**Provider Schema:**
```go
ForceNew: true
```

**Implementation:**
```hcl
replace_triggers_external_values = {
  edge_zone = { value = local.normalized_edge_zone }
}
```

**Why track normalized value:** The normalized value is what's compared against Azure state. Tracking the raw value would cause false positives (e.g., `"West US"` vs `"westus"`).

**Key stable:** The key `edge_zone` is always present, even when value is `null`, ensuring key stability.

### 5. extendedLocation Structure

**Provider Logic:**
```go
ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string))

func expandEdgeZoneModel(input string) *edgezones.Model {
	normalized := edgezones.Normalize(input)
	if normalized == "" {
		return nil
	}
	return &edgezones.Model{
		Name: normalized,
	}
}
```

**Implementation:**
```hcl
extendedLocation = local.normalized_edge_zone != null ? {
  name = local.normalized_edge_zone
  type = "EdgeZone"
} : null
```

**Logic:**
- If `edge_zone` is `null` or empty, `extendedLocation` is `null` (entire object omitted)
- If `edge_zone` has a value, create `extendedLocation` object with `name` (normalized) and `type = "EdgeZone"`
- The `type` field is hardcoded to `"EdgeZone"` as per Azure API requirements

## Deferred Work Completion

**Check `following.md`:** File does not exist, no deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics:**
- `null` = No edge zone specified (standard Azure region)
- Empty string = Invalid (caught by validation)
- Omitting field entirely = Same as `null`

**2. Normalization Consistency:**
- User input: `"West US"`, `"west us"`, `"westus"` → All normalize to `"westus"`
- Prevents unnecessary replacements when only casing/spacing changes
- Matches provider's StateFunc behavior exactly

**3. ForceNew Behavior:**
- Changing from `null` to non-null → Triggers replacement
- Changing from non-null to `null` → Triggers replacement
- Changing from one edge zone to another → Triggers replacement
- Changing only casing/spacing → No replacement (normalized values are identical)

**4. Azure API Interaction:**
- When `extendedLocation` is `null`, Azure treats resource as standard region resource
- When present, both `name` and `type` must be provided
- `type` must be exactly `"EdgeZone"` (case-sensitive in API)

**5. Idempotency:**
- Normalized value ensures idempotent operations
- Same logical edge zone (different representations) → Same normalized value → No diff

**6. Safe References:**
- Always check `local.normalized_edge_zone != null` before creating `extendedLocation` object
- Prevents creating empty objects with missing required fields

## Checklist

- ✅ Property in correct local (body.extendedLocation, not properties)
- ✅ ForceNew wrapped: `edge_zone = { value = local.normalized_edge_zone }`
- ✅ ALL logic EXACTLY replicated from provider:
  - ✅ Normalization (StateFunc) - lowercase + remove spaces
  - ✅ DiffSuppressFunc behavior - normalized comparison
  - ✅ ForceNew behavior - schema declaration
  - ✅ expandEdgeZoneModel logic - null if empty, object with name+type otherwise
- ✅ Validations IMPLEMENTED in variables.tf:
  - ✅ StringIsNotEmpty validation
- ✅ Hidden fields checked: `type` field is hardcoded, not a hidden user-configurable field
- ✅ Deferred work in following.md: N/A (no work to defer)
- ✅ Deferred work from following.md: N/A (file doesn't exist)
- ✅ Critical review completed
- ✅ Edge Case Analysis in proof
- ✅ Proof created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only edge_zone implementation added, no other tasks' content included

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #7 - edge_zone

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented with Mode 1 (Direct Value Tracking). Wrapped in object with stable key tracking full normalized value.

✅ **Stable Keys:** Key `edge_zone` is always present in `replace_triggers_external_values`, using `{ value = ... }` pattern.

✅ **Phase Detection:** Field correctly placed in `local.body.extendedLocation` (Create phase - assigned before primary `CreateOrUpdateThenPoll`).

✅ **Type Conversion:** Correct conversion from Terraform string to Azure API object structure with `name` and `type` fields.

✅ **Null Handling:** Correctly propagates null semantics - entire `extendedLocation` object is null when field is null.

✅ **Validations:** Provider's `StringIsNotEmpty` validation exactly replicated in `variables.tf` validation block.

✅ **StateFunc & DiffSuppressFunc:** Normalization logic (lowercase + remove spaces) exactly replicated. Using normalized value in both triggers and body achieves correct diff suppression behavior.

✅ **Assignment Path:** Correctly placed at `body.extendedLocation` (root level, not in properties), matching provider's assignment to `vnet.ExtendedLocation`.

✅ **Hidden Fields:** `type = "EdgeZone"` correctly hardcoded as per provider's expand function.

✅ **Sensitive Field Handling:** N/A - field is not sensitive or write-only.

✅ **Shared Path Merge:** No merge conflicts - `extendedLocation` appears only once at body root level.

✅ **Root-Level Defaults:** N/A - field has no default value, correctly uses `default = null` without `nullable = false`.

✅ **AzAPI 2.0+ Compliance:** No JSON encoding/decoding, direct object assignment used correctly.

✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist).

✅ **Deferred Work Recording:** No deferrals made by this task.

✅ **Edge Cases:** All edge cases properly analyzed:
- Null semantics (no edge zone vs standard region)
- Normalization consistency across different input formats
- ForceNew behavior for all transition types
- Safe object construction with null checks
- Idempotency through normalized value tracking

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The implementation correctly handles:
1. Normalization (StateFunc) - lowercase + remove spaces
2. Diff suppression (DiffSuppressFunc) - normalized comparison
3. Validation (StringIsNotEmpty) - exact replication
4. ForceNew behavior - schema-based with normalized value tracking
5. Expand logic - null handling and object structure with hidden `type` field

**Status:** APPROVED ✅

---
