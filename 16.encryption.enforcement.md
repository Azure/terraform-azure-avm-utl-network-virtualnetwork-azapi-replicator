# Task #16 - encryption.enforcement Argument

## Summary
Implemented `encryption.enforcement` field which specifies if the encrypted Virtual Network allows VMs that do not support encryption. Maps directly to `properties.encryption.enforcement` in the API with validation for enum values "DropUnencrypted" and "AllowUnencrypted".

## Shadow Implementation

```hcl
# In variables.tf
variable "encryption" {
  type = object({
    enforcement = string  # <-
  })
  default     = null
  description = <<-EOT
 - `enforcement` - (Required) Specifies if the encrypted Virtual Network allows VM that does not support encryption. Possible values are `DropUnencrypted` and `AllowUnencrypted`.
EOT
  
  validation {  # <-
    condition = var.encryption == null || contains(["DropUnencrypted", "AllowUnencrypted"], var.encryption.enforcement)  # <-
    error_message = "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."  # <-
  }  # <-
}

# In migrate_main.tf
locals {
  body = {
    properties = {
      encryption = var.encryption != null ? {  # <-
        enabled = true  # <-
        enforcement = var.encryption.enforcement  # <-
      } : null  # <-
    }
  }
}
```

## Create Phase Verification

### Pattern Identification
Single-phase creation pattern - the `enforcement` field is set during primary `CreateOrUpdateThenPoll` operation within the encryption block.

### Go Code Evidence

From `resourceVirtualNetworkCreate`:
```go
vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
if err != nil {
    return err
}

vnet := virtualnetworks.VirtualNetwork{
    Properties:       vnetProperties,  // Contains .Encryption.Enforcement
}

if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

From `expandVirtualNetworkProperties`:
```go
if v, ok := d.GetOk("encryption"); ok {
    if vList := v.([]interface{}); len(vList) > 0 && vList[0] != nil {
        encryptionConf := vList[0].(map[string]interface{})
        properties.Encryption = &virtualnetworks.VirtualNetworkEncryption{
            Enabled:     true,
            Enforcement: pointer.To(virtualnetworks.VirtualNetworkEncryptionEnforcement(encryptionConf["enforcement"].(string))),
        }
    }
}
```

From `resourceVirtualNetworkUpdate`:
```go
if d.HasChange("encryption") {
    // nil out the current values in case `encryption` has been removed from the config file
    payload.Properties.Encryption = expandVirtualNetworkEncryption(d.Get("encryption").([]interface{}))
}
```

### Classification
- **Phase**: Create (primary `CreateOrUpdateThenPoll`)
- **Also Used In**: Update (same expand logic)
- **Location**: `local.body.properties.encryption.enforcement`

## Assignment Path Verification

### Predicted Path
`var.encryption.enforcement` → `local.body.properties.encryption.enforcement`

### Go Code Evidence

**Step 1**: Schema → Config data retrieval
```go
if v, ok := d.GetOk("encryption"); ok {
    if vList := v.([]interface{}); len(vList) > 0 && vList[0] != nil {
        encryptionConf := vList[0].(map[string]interface{})
        // Access enforcement field:
        encryptionConf["enforcement"].(string)
```

**Step 2**: Expand to SDK struct
```go
properties.Encryption = &virtualnetworks.VirtualNetworkEncryption{
    Enabled:     true,
    Enforcement: pointer.To(virtualnetworks.VirtualNetworkEncryptionEnforcement(encryptionConf["enforcement"].(string))),
}
```

**Step 3**: Assignment to VirtualNetwork.Properties
```go
vnet := virtualnetworks.VirtualNetwork{
    Properties:       vnetProperties,  // Contains .Encryption.Enforcement
}
```

### Verified Path
`encryption.enforcement` → `encryptionConf["enforcement"]` → `properties.Encryption.Enforcement` → `vnet.Properties.Encryption.Enforcement` → API body `properties.encryption.enforcement`

### Path Comparison
✅ **MATCH**: The predicted path `properties.encryption.enforcement` matches the verified path from provider implementation.

## Provider Schema

From `resourceVirtualNetworkSchema()` (documented in Task #15):
```go
"encryption": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "enforcement": {
                Type:     pluginsdk.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(virtualnetworks.VirtualNetworkEncryptionEnforcementDropUnencrypted),
                    string(virtualnetworks.VirtualNetworkEncryptionEnforcementAllowUnencrypted),
                }, false),
            },
        },
    },
},
```

**Key Properties**:
- **Type**: String (`TypeString`)
- **Required**: true (within encryption block)
- **Validation**: `StringInSlice` with two allowed values:
  - `DropUnencrypted`
  - `AllowUnencrypted`
- **Case Sensitive**: false parameter means case-sensitive validation

## Azure API Schema

From Azure API schema query result (Task #15):
```
"encryption":ObjectWithOptionalAttrs(map[string]Type{
    "enabled":Bool, 
    "enforcement":String
}, []string{"enforcement"})
```

**API Structure**:
- `properties.encryption.enforcement`: String (required in API schema)
- Type: String enum with two possible values

## Hidden Fields

None. The `enforcement` field is explicitly defined in the provider schema and directly mapped to the API.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Type | Notes |
|------------------------|----------------------|------|-------|
| `enforcement` | `properties.encryption.enforcement` | String | Required, enum with 2 values |

**Case Mapping**: Direct 1:1 mapping, both use `enforcement` (no case conversion needed for this field name).

## Special Handling

### Validation Implementation

**Category**: Value Constraint Validation (MANDATORY)

**Provider Validation**:
```go
ValidateFunc: validation.StringInSlice([]string{
    string(virtualnetworks.VirtualNetworkEncryptionEnforcementDropUnencrypted),
    string(virtualnetworks.VirtualNetworkEncryptionEnforcementAllowUnencrypted),
}, false),
```

**Enum Values**:
- `DropUnencrypted`: Drop traffic from VMs that don't support encryption
- `AllowUnencrypted`: Allow traffic from VMs that don't support encryption

**Implementation in variables.tf**:
```hcl
validation {
    condition = var.encryption == null || contains(["DropUnencrypted", "AllowUnencrypted"], var.encryption.enforcement)
    error_message = "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."
}
```

**Rationale**:
- MANDATORY validation per executor.md rules (Category 1 - Value Constraints)
- Replicates exact provider behavior: restricts to two allowed enum values
- Validation must execute at Terraform plan time for fast failure
- The validation condition includes `var.encryption == null` guard to allow the entire encryption block to be optional

### No ForceNew Behavior

**Evidence from Provider**:
- Schema has `ForceNew: false` (implicitly - not marked as ForceNew)
- Update method includes: `if d.HasChange("encryption") { ... }`
- No `CustomizeDiff` logic for encryption field in resource function

**Conclusion**: Changes to `enforcement` value do NOT force resource replacement - updates are performed in-place.

**Implementation**: No entry in `replace_triggers_external_values` required.

### No Sensitive Fields

**Evidence**: No `Sensitive: true` flag in schema, no WriteOnly designation in API schema.

**Conclusion**: Field value goes in `body`, not `sensitive_body`.

### Parent Block Conditional Logic

**Dependency**: This field only exists when parent `var.encryption` block is present.

**Implementation**:
```hcl
encryption = var.encryption != null ? {
    enabled = true
    enforcement = var.encryption.enforcement  # Safe: encryption is guaranteed non-null here
} : null
```

**Safety**: The `var.encryption != null` guard ensures we never access `.enforcement` on a null object.

## Deferred Work Completion

**Check**: Reviewed `following.md` - file does not exist, so no deferred work to complete.

## Critical Review & Edge Cases

### Null Semantics

**Field Level**:
- **Required**: `enforcement` is Required within the encryption block (when encryption block is present)
- **Validation**: When `var.encryption != null`, `var.encryption.enforcement` MUST be one of the two allowed enum values
- **Parent Block**: When `var.encryption == null`, the entire encryption object is omitted (handled by Task #15)

**Meaning**:
- `var.encryption = null`: No encryption configuration (entire block omitted)
- `var.encryption = { enforcement = "DropUnencrypted" }`: Encryption enabled with DropUnencrypted enforcement
- `var.encryption = { enforcement = "AllowUnencrypted" }`: Encryption enabled with AllowUnencrypted enforcement

### Boundary Conditions

**Empty String**:
- **Input**: `var.encryption = { enforcement = "" }`
- **Validation**: FAILS validation (not in allowed list)
- **Error**: "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."

**Wrong Case**:
- **Input**: `var.encryption = { enforcement = "dropunencrypted" }`
- **Validation**: FAILS validation (contains() is case-sensitive)
- **Error**: "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."
- **Note**: Provider uses case-sensitive validation (false parameter to StringInSlice)

**Invalid Value**:
- **Input**: `var.encryption = { enforcement = "InvalidValue" }`
- **Validation**: FAILS validation
- **Error**: "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."

### Idempotency

**Stable Value**:
- **Scenario**: Apply with `enforcement = "DropUnencrypted"`, then apply again with same value
- **Behavior**: No change detected, no API call made
- **Result**: Idempotent ✅

**Value Change**:
- **Scenario**: Change from `"DropUnencrypted"` to `"AllowUnencrypted"`
- **Behavior**: Update in-place (no ForceNew)
- **Result**: Idempotent across updates ✅

**Block Presence Toggle**:
- **Scenario**: Add/remove entire encryption block
- **Behavior**: In-place update (no ForceNew), entire encryption object added/removed
- **Result**: Idempotent ✅

### Safe References

**Null Check**:
```hcl
encryption = var.encryption != null ? {
    enforcement = var.encryption.enforcement  # Safe: var.encryption guaranteed non-null
} : null
```

**Analysis**:
- ✅ Parent null check (`var.encryption != null`) protects field access
- ✅ No risk of accessing `.enforcement` on null object
- ✅ Terraform type system enforces `enforcement` presence in object (Required field)

**Type Safety**:
- Variable type `object({ enforcement = string })` ensures field always exists when object is non-null
- Validation ensures value is always one of two allowed strings

## Edge Case Analysis

### Case 1: encryption = null
- **Input**: `var.encryption = null`
- **Output**: `encryption` key is not present in API body
- **Behavior**: Virtual network created/updated without encryption
- **Enforcement Field**: Not applicable (parent block absent)

### Case 2: encryption with DropUnencrypted
- **Input**: `var.encryption = { enforcement = "DropUnencrypted" }`
- **Output**: `encryption = { enabled = true, enforcement = "DropUnencrypted" }`
- **Behavior**: Encryption enabled, unencrypted traffic from VMs is dropped
- **Security Posture**: More secure (enforces encryption)

### Case 3: encryption with AllowUnencrypted
- **Input**: `var.encryption = { enforcement = "AllowUnencrypted" }`
- **Output**: `encryption = { enabled = true, enforcement = "AllowUnencrypted" }`
- **Behavior**: Encryption enabled, but unencrypted traffic from VMs is allowed
- **Security Posture**: Less restrictive (allows mixed encryption)

### Case 4: Switching enforcement values
- **Transition**: `"DropUnencrypted"` → `"AllowUnencrypted"` (or reverse)
- **ForceNew**: No (in-place update)
- **Behavior**: Update virtual network encryption policy without replacement
- **Impact**: Immediate policy change on virtual network

### Case 5: Adding encryption to existing VNet
- **Transition**: `null` → `{ enforcement = "DropUnencrypted" }`
- **ForceNew**: No (in-place update)
- **Behavior**: Encryption enabled on existing virtual network
- **Note**: Provider supports adding encryption post-creation

### Case 6: Removing encryption from VNet
- **Transition**: `{ enforcement = "..." }` → `null`
- **ForceNew**: No (in-place update)
- **Behavior**: Encryption disabled on virtual network
- **API Behavior**: Entire encryption object removed (from Update method: "nil out the current values")

### Case 7: Invalid value provided
- **Input**: `var.encryption = { enforcement = "SomeOtherValue" }`
- **Result**: Terraform plan fails at validation stage
- **Error**: "The enforcement must be either 'DropUnencrypted' or 'AllowUnencrypted'."
- **Timing**: Fast failure (plan time, not apply time)

## Checklist

- ✅ Field added to `local.body.properties.encryption.enforcement`
- ✅ Direct value assignment (not wrapped - not ForceNew)
- ✅ Validation IMPLEMENTED in variables.tf (enum value check)
- ✅ No ForceNew handling needed (field is updatable)
- ✅ No sensitive handling needed (not sensitive field)
- ✅ Hidden fields checked (none for this field)
- ✅ Deferred work checked (no following.md file)
- ✅ Critical review completed (null safety, edge cases, idempotency)
- ✅ Edge Case Analysis section included
- ✅ Proof document created
- ✅ Implementation exactly matches provider behavior with Go code evidence

## Self-Review

**Did I add ONLY what this specific task requires?**
✅ Yes - Added only the `enforcement` field implementation within the existing encryption block structure

**Did I add hidden fields that belong to `__check_*_hidden_fields__` tasks?**
✅ No - The `enabled` field was already handled by Task #15 (parent block skeleton)

**Did I add fields from other tasks?**
✅ No - Only implemented the `enforcement` field as specified in Task #16

**Did I follow parent block structure?**
✅ Yes - Used the skeleton created by Task #15, simply replacing the comment placeholder with the field implementation

**Final Verification**
✅ Implementation exactly matches provider behavior with Go code evidence
✅ No "more conservative" or "simpler" approaches taken
✅ All validation logic from provider replicated exactly (StringInSlice with two enum values)
✅ Correct path: `properties.encryption.enforcement`
✅ Correct type: String
✅ Correct validation: Enum with "DropUnencrypted" and "AllowUnencrypted"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #16 - encryption.enforcement

### Validation Results

✅ **ForceNew Logic:** No ForceNew required - field is updatable in-place (correctly documented with provider Update method evidence)
✅ **Stable Keys:** Not applicable (field is not ForceNew)
✅ **Phase Detection:** Field correctly placed in `local.body.properties.encryption` (Create phase)
✅ **Type Conversion:** Direct assignment string → string, no conversion needed
✅ **Null Handling:** Correctly uses parent block conditional (`var.encryption != null`) to safely access nested field
✅ **Validations:** Validation EXACTLY replicated from provider - `StringInSlice` with two enum values ("DropUnencrypted", "AllowUnencrypted") implemented as `contains()` check in variables.tf
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive edge case analysis including null semantics, empty string, case sensitivity, invalid values, idempotency, and safe references
✅ **Sensitive Handling:** Correctly placed in `body` (not sensitive field)
✅ **Assignment Path:** Complete path verification from provider schema through expand function to API structure with Go code evidence
✅ **Provider Behavior Replication:** Implementation EXACTLY matches provider validation logic with proper case-sensitive enum validation

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The validation logic correctly replicates the provider's `StringInSlice` validation with the exact two enum values. The field is properly nested within the encryption block structure, safely accessed via parent null check, and correctly placed in the Create phase. All edge cases have been thoroughly analyzed and documented.

**Status:** APPROVED ✅

---
