# Task #15 - encryption Block Structure Skeleton

## Summary
Created structure skeleton for `encryption` block with conditional presence based on `var.encryption`. Identified hidden field `enabled` which is hardcoded to `true` by the provider.

## Shadow Implementation

```hcl
locals {
  body = { 
    properties = {
      encryption = var.encryption != null ? {  # <-
        enabled = true  # Hardcoded to true by provider (hidden field)  # <-
        # enforcement = ... # Task #16  # <-
      } : null  # <-
    }
  }
}
```

## Create Phase Verification

### Pattern Identification
Single-phase creation pattern - the `encryption` block is set during primary `CreateOrUpdateThenPoll` operation.

### Go Code Evidence

From `resourceVirtualNetworkCreate`:
```go
vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
if err != nil {
    return err
}

vnet := virtualnetworks.VirtualNetwork{
    Name:             pointer.To(id.VirtualNetworkName),
    ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
    Location:         pointer.To(location.Normalize(d.Get("location").(string))),
    Properties:       vnetProperties,  // encryption is part of Properties
    Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
}

if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

From `expandVirtualNetworkProperties`:
```go
if v, ok := d.GetOk("encryption"); ok {
    if vList := v.([]interface{}); len(vList) > 0 && vList[0] != nil {
        encryptionConf := vList[0].(map[string]interface{})
        properties.Encryption = &virtualnetworks.VirtualNetworkEncryption{
            Enabled:     true,  // HIDDEN FIELD: Hardcoded to true
            Enforcement: pointer.To(virtualnetworks.VirtualNetworkEncryptionEnforcement(encryptionConf["enforcement"].(string))),
        }
    }
}
```

### Classification
- **Phase**: Create (primary `CreateOrUpdateThenPoll`)
- **Location**: `local.body.properties.encryption`

## Assignment Path Verification

### Predicted Path
`var.encryption` → `local.body.properties.encryption`

### Go Code Evidence

**Step 1**: Schema → Config data retrieval
```go
if v, ok := d.GetOk("encryption"); ok {
    if vList := v.([]interface{}); len(vList) > 0 && vList[0] != nil {
        encryptionConf := vList[0].(map[string]interface{})
```

**Step 2**: Expand to SDK struct
```go
properties.Encryption = &virtualnetworks.VirtualNetworkEncryption{
    Enabled:     true,  // HARDCODED
    Enforcement: pointer.To(virtualnetworks.VirtualNetworkEncryptionEnforcement(encryptionConf["enforcement"].(string))),
}
```

**Step 3**: Assignment to VirtualNetwork.Properties
```go
vnet := virtualnetworks.VirtualNetwork{
    Properties:       vnetProperties,  // Contains .Encryption
}
```

### Verified Path
`encryption` block → `vnetProperties.Encryption` → `vnet.Properties.Encryption` → API body `properties.encryption`

### Path Comparison
✅ **MATCH**: The predicted path `properties.encryption` matches the verified path from provider implementation.

## Provider Schema

From `resourceVirtualNetworkSchema()`:
```go
"encryption": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "enforcement": {
                Type:     pluginsdk.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice([]string{
                    string(virtualnetworks.VirtualNetworkEncryptionEnforcementDropUnencrypted),
                    string(virtualnetworks.VirtualNetworkEncryptionEnforcementAllowUnencrypted),
                }, false),
            },
        },
    },
},
```

**Key Properties**:
- **Type**: Block (`TypeList`)
- **Optional**: true
- **MaxItems**: 1 (single block)
- **Fields**:
  - `enforcement`: Required, string with validation

## Azure API Schema

From Azure API schema query result:
```
"encryption":ObjectWithOptionalAttrs(map[string]Type{
    "enabled":Bool, 
    "enforcement":String
}, []string{"enforcement"})
```

**API Structure**:
- `properties.encryption.enabled`: Boolean (optional in API, but hardcoded to true by provider)
- `properties.encryption.enforcement`: String (required in API)

## Hidden Fields

### Hidden Field: `enabled`

**Evidence from Expand Function**:
```go
properties.Encryption = &virtualnetworks.VirtualNetworkEncryption{
    Enabled:     true,  // HARDCODED - not in Terraform schema
    Enforcement: pointer.To(virtualnetworks.VirtualNetworkEncryptionEnforcement(encryptionConf["enforcement"].(string))),
}
```

**Analysis**:
- The `enabled` field is **NOT** in the Terraform provider schema
- It is **HARDCODED** to `true` in the expand function
- This means when `encryption` block is present, `enabled` is always `true`
- When `encryption` block is absent, the entire encryption object is `nil`

**Implementation**:
Added `enabled = true` as a hardcoded value in the skeleton, with comment indicating it's a hidden field set by the provider.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Type |
|------------------------|----------------------|------|
| `encryption` (block) | `properties.encryption` | Object |
| N/A (hidden) | `properties.encryption.enabled` | Boolean (hardcoded to true) |
| `enforcement` | `properties.encryption.enforcement` | String (Task #16) |

## Special Handling

### Block Conditionality
- **Condition**: `var.encryption != null`
- **Behavior**: When `null`, the entire `encryption` object is omitted from API body
- **Reason**: With `ignore_null_property = true`, null values are automatically ignored by AzAPI provider

### Hidden Field: enabled
- **Value**: Always `true` when encryption block is present
- **Implementation**: Hardcoded in skeleton
- **Reason**: Provider always sets this to true - not exposed in schema

### No ForceNew
- **Evidence**: No `ForceNew: true` in schema
- **Conclusion**: Encryption block can be added/removed/modified without forcing replacement

### No Sensitive Fields
- **Evidence**: No sensitive or WriteOnly fields in this block
- **Conclusion**: All fields go in `body`, none in `sensitive_body`

## Child Tasks Ready for Delegation

Based on the skeleton structure created, the following child task is now ready:

| Task # | Field | Type | Status |
|--------|-------|------|--------|
| 16 | encryption.enforcement | Argument | Ready for delegation |

## Critical Review & Edge Cases

### Null Semantics
- **`var.encryption = null`**: Entire encryption object is omitted from API (expected behavior)
- **Meaning**: No encryption configuration for the virtual network

### Hidden Field Behavior
- **`enabled` field**: Always `true` when encryption block exists
- **API Expectation**: When encryption object is present, `enabled` must be `true`
- **Provider Logic**: Hardcodes `true` to ensure consistency

### Idempotency
- **Block presence**: Controlled by `var.encryption != null`
- **Stability**: No conditional key appearance/disappearance issues
- **Result**: Idempotent across multiple applies

### Safe References
- **Null check**: `var.encryption != null` guards the entire block construction
- **No nested access**: Child field (enforcement) is handled in Task #16
- **Safe**: No risk of accessing properties on null object

## Edge Case Analysis

### Case 1: encryption = null
- **Input**: `var.encryption = null`
- **Output**: `encryption` key is not present in API body
- **Behavior**: Virtual network created without encryption

### Case 2: encryption block provided
- **Input**: `var.encryption = { enforcement = "DropUnencrypted" }`
- **Output**: `encryption = { enabled = true, enforcement = "DropUnencrypted" }`
- **Behavior**: Virtual network created with encryption, enabled is hardcoded to true

### Case 3: Updating from null to non-null
- **Transition**: Add encryption block to existing virtual network
- **ForceNew**: No (not marked as ForceNew)
- **Behavior**: In-place update - encryption is enabled on existing virtual network

### Case 4: Updating from non-null to null
- **Transition**: Remove encryption block from virtual network
- **ForceNew**: No
- **Behavior**: In-place update - encryption is disabled (entire object removed)

## Checklist

- ✅ Block skeleton created with conditional structure
- ✅ Hidden field `enabled = true` identified and hardcoded in skeleton
- ✅ Comment placeholder added for child argument (Task #16)
- ✅ Create phase verified (single-phase, part of primary CreateOrUpdateThenPoll)
- ✅ Assignment path verified (properties.encryption)
- ✅ No ForceNew handling needed (not marked as ForceNew)
- ✅ No sensitive fields (all in body)
- ✅ No validation needed at block level (enforcement validation in Task #16)
- ✅ Null semantics documented (null = omit entire object)
- ✅ Child task identified (Task #16 ready for delegation)
- ✅ Edge cases analyzed
- ✅ Proof document created
- ✅ Track.md ready to be updated

## Self-Review

**Did I add ONLY what this specific task requires?**
✅ Yes - Added only the `encryption` block skeleton with the hidden `enabled` field and placeholder for `enforcement`

**Did I add hidden fields that belong to `__check_*_hidden_fields__` tasks?**
✅ No - The `enabled` field is part of the encryption block structure itself, discovered by checking this block's expand function as required by Type 3 task instructions (step 3: "Check expand for hidden")

**Did I add fields from other tasks?**
✅ No - Only created the skeleton structure; `enforcement` field implementation is correctly deferred to Task #16

**Final Verification**
✅ Implementation exactly matches provider behavior with Go code evidence
✅ No "more conservative" or "simpler" approaches taken
✅ All logic from provider expand function replicated (hardcoded `enabled = true`)

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #15 - encryption

### Task #15 Specific Validation

✅ **Block Structure Skeleton:** Correctly created with conditional `var.encryption != null ? {...} : null` pattern
✅ **Hidden Field Discovery:** Correctly identified and hardcoded `enabled = true` from expand function
✅ **Type 3 Task Requirements:** All steps properly followed (skeleton creation, expand function check, placeholder for child task)
✅ **Phase Detection:** Correctly identified as Create phase (part of primary CreateOrUpdateThenPoll)
✅ **Assignment Path:** Correctly verified as `properties.encryption`
✅ **Null Handling:** Appropriate use of direct null assignment with `ignore_null_property = true`
✅ **Child Task Placeholder:** Correctly deferred `enforcement` field to Task #16
✅ **Proof Document:** Complete with all required sections and Go code evidence
✅ **No ForceNew:** Correctly identified no ForceNew handling needed
✅ **No Sensitive Fields:** Correctly identified all fields go in `body`
✅ **Edge Cases:** Comprehensive edge case analysis provided
✅ **Self-Review:** Confirmed only task-specific scope implemented

### Systemic Issue Found (Not Task #15 Specific)

#### Issue 1: Missing `retry` Output

**Problem:**
The `migrate_outputs.tf` file was missing the required `retry` output that is specified in executor.md Initial Templates (line 652).

**Executor.md Rule (Lines 645-661):**
```hcl
output "locks" { value = local.locks }
output "retry" { value = local.retry }
```

**What Was Missing:**
- No `output "retry"` declaration in `migrate_outputs.tf`
- `retry` was embedded inside `azapi_header` but not available as separate local/output

**Why This Violates executor.md:**
The Initial Templates section explicitly shows `output "retry" { value = local.retry }`, indicating that:
1. `local.retry` must exist as a separate local variable
2. It must be exposed via an output named "retry"

**Root Cause:**
This was inherited from Task #1 (name) which created the initial structure but didn't establish the separate `local.retry` variable as shown in the template.

### Corrections Made

#### Fix 1: Extracted `retry` as Separate Local

**Changed Files:**
- `migrate_main.tf`: Extracted `retry` from inline value to separate local variable
- `migrate_outputs.tf`: Added missing `output "retry"` declaration

**New Implementation (migrate_main.tf):**
```hcl
locals {
  retry = null  # NEW: Extracted as separate local
  
  azapi_header = {
    type                  = "Microsoft.Network/virtualNetworks@2024-07-01"
    name                  = var.name
    location              = local.normalized_location
    parent_id             = var.resource_group_id
    tags                  = var.tags
    ignore_null_property  = true
    retry                 = local.retry  # CHANGED: Reference separate local
  }
}
```

**New Implementation (migrate_outputs.tf):**
```hcl
output "locks" { value = local.locks }
output "retry" { value = local.retry }  # NEW: Added missing output
```

**Why This is EXACT:**
Matches the executor.md Initial Templates structure line-by-line:
- Separate `local.retry` variable exists
- Output references `local.retry` as specified in template
- `azapi_header` can still reference `local.retry` for consistency

**Verification:**
- Template conformance: ✅ Now matches executor.md lines 645-661
- Output completeness: ✅ All required outputs now present
- Structure consistency: ✅ Follows template pattern exactly

### Compliance Statement

**Task #15 Implementation:**
This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The encryption block skeleton correctly:
- Creates conditional structure based on `var.encryption != null`
- Hardcodes `enabled = true` as the provider does
- Defers child field implementation to appropriate task
- Follows Type 3 (Block Structure Skeleton) requirements precisely

**Systemic Fix:**
The missing `retry` output issue has been corrected to ensure exact conformance with executor.md Initial Templates. This was a structural issue from Task #1, not related to Task #15's scope, but has been resolved to maintain template compliance.

**Status:** CORRECTED AND APPROVED ✅

---
