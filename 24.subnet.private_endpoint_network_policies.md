# Task #24: subnet.private_endpoint_network_policies

## Summary
Implemented `subnet.private_endpoint_network_policies` field which controls network policies for private endpoints on the subnet. The field is Optional with a default value of "Disabled" and supports four possible values: "Disabled", "Enabled", "NetworkSecurityGroupEnabled", and "RouteTableEnabled". The implementation includes validation for allowed values and direct mapping to the Azure API's `privateEndpointNetworkPolicies` property.

## Shadow Implementation

```hcl
# variables.tf
variable "subnet" {
  type = set(object({
    # ... other fields ...
    private_endpoint_network_policies = optional(string, "Disabled") # <-
    # ... other fields ...
  }))

  # ... other validations ...

  validation { # <-
    condition = var.subnet == null || alltrue([ # <-
      for s in var.subnet : contains(["Disabled", "Enabled", "NetworkSecurityGroupEnabled", "RouteTableEnabled"], s.private_endpoint_network_policies) # <-
    ]) # <-
    error_message = "Each subnet's private_endpoint_network_policies must be one of: 'Disabled', 'Enabled', 'NetworkSecurityGroupEnabled', 'RouteTableEnabled'." # <-
  } # <-
}

# migrate_main.tf
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name
          properties = merge(
            length(subnet.address_prefixes) == 1 ? {
              addressPrefix = subnet.address_prefixes[0]
            } : {
              addressPrefixes = subnet.address_prefixes
            },
            {
              defaultOutboundAccess          = subnet.default_outbound_access_enabled
              privateEndpointNetworkPolicies = subnet.private_endpoint_network_policies # <-
              # ... other fields ...
            }
          )
        }
      ] : null
    }
  }
}
```

## Create Phase Verification

**Query Create Method:**

```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	// ...
	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ...
}
```

**Expand Function:**

```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	// ...
	if subs := d.Get("subnet").(*pluginsdk.Set); subs.Len() > 0 {
		for _, subnet := range subs.List() {
			subnet := subnet.(map[string]interface{})
			// ...
			privateEndpointNetworkPolicies := virtualnetworks.VirtualNetworkPrivateEndpointNetworkPolicies(subnet["private_endpoint_network_policies"].(string))
			// ...
			subnetObj.Properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)
			// ...
			subnets = append(subnets, *subnetObj)
		}
	}
	// ...
	properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
		// ...
		Subnets: &subnets,
	}
	return properties, &routeTables, nil
}
```

**Pattern:** Single-phase operation. The `private_endpoint_network_policies` field is processed during the primary Create operation within `expandVirtualNetworkProperties()`, which constructs the subnet properties. These properties are included in the main `VirtualNetwork` object passed to `CreateOrUpdateThenPoll()`.

**Classification:** Create Phase - The field is set during the initial resource creation as part of the subnet properties in the main virtual network payload.

**Decision:** Implement in `local.body` under `properties.subnets[].properties.privateEndpointNetworkPolicies`.

## Assignment Path Verification

**Predicted Path:** `body.properties.subnets[].properties.privateEndpointNetworkPolicies`

**Provider Source Code Evidence:**

```go
// Step 1: Get value from config
privateEndpointNetworkPolicies := virtualnetworks.VirtualNetworkPrivateEndpointNetworkPolicies(subnet["private_endpoint_network_policies"].(string))

// Step 2: Assign to SubnetPropertiesFormat
subnetObj.Properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)

// Step 3: Append to subnets slice
subnets = append(subnets, *subnetObj)

// Step 4: Assign to VirtualNetworkPropertiesFormat
properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
	Subnets: &subnets,
}

// Step 5: Return properties (assigned to vnet.Properties in Create)
return properties, &routeTables, nil

// Step 6: In Create function
vnet := virtualnetworks.VirtualNetwork{
	Properties: vnetProperties,  // Contains the subnets with privateEndpointNetworkPolicies
}
```

**Verified Path:** `body.properties.subnets[].properties.privateEndpointNetworkPolicies`

**Path Comparison:** ✅ Match - The predicted path matches the actual assignment path in the provider source code.

## Provider Schema

```go
"subnet": {
	Type:       pluginsdk.TypeSet,
	Optional:   true,
	Computed:   true,
	ConfigMode: pluginsdk.SchemaConfigModeAttr,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			// ...
			"private_endpoint_network_policies": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				Default:      string(subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled),
				ValidateFunc: validation.StringInSlice(subnets.PossibleValuesForVirtualNetworkPrivateEndpointNetworkPolicies(), false),
			},
			// ...
		},
	},
},
```

**Key Details:**
- **Type:** `TypeString`
- **Optional:** `true`
- **Default:** `string(subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled)` which is "Disabled"
- **ValidateFunc:** `validation.StringInSlice(subnets.PossibleValuesForVirtualNetworkPrivateEndpointNetworkPolicies(), false)` - Validates against allowed enum values
- **ForceNew:** Not present
- **Sensitive:** `false`
- **Computed:** `false`

**Possible Values:** Based on the provider documentation and schema description:
- `Disabled` (default)
- `Enabled`
- `NetworkSecurityGroupEnabled`
- `RouteTableEnabled`

## Azure API Schema

**Property Path:** `properties.subnets[].properties.privateEndpointNetworkPolicies`

**Azure API Documentation:**
The field is part of the subnet properties within the virtual network resource. According to the provider source code and Azure SDK types, this corresponds to the `VirtualNetworkPrivateEndpointNetworkPolicies` enum type with the possible values listed above.

## Hidden Fields

None. The field is directly exposed in the Terraform schema with no hidden transformations or additional logic applied beyond the enum type conversion.

## Mapping

| Terraform Field | Azure API Field |
|----------------|-----------------|
| `subnet.private_endpoint_network_policies` | `properties.subnets[].properties.privateEndpointNetworkPolicies` |

**Naming Convention:** 
- Terraform: `private_endpoint_network_policies` (snake_case)
- Azure API: `privateEndpointNetworkPolicies` (camelCase)

## Special Handling

### Validation

**Implementation in variables.tf:**

```hcl
validation {
  condition = var.subnet == null || alltrue([
    for s in var.subnet : contains(["Disabled", "Enabled", "NetworkSecurityGroupEnabled", "RouteTableEnabled"], s.private_endpoint_network_policies)
  ])
  error_message = "Each subnet's private_endpoint_network_policies must be one of: 'Disabled', 'Enabled', 'NetworkSecurityGroupEnabled', 'RouteTableEnabled'."
}
```

**Rationale:** The provider uses `validation.StringInSlice(subnets.PossibleValuesForVirtualNetworkPrivateEndpointNetworkPolicies(), false)` to ensure only valid enum values are accepted. This validation is replicated in the variable definition to provide the same protection for AzAPI users.

### Default Value

**Implementation:**

```hcl
variable "subnet" {
  type = set(object({
    private_endpoint_network_policies = optional(string, "Disabled")
  }))
}
```

**Rationale:** The provider schema specifies `Default: string(subnets.VirtualNetworkPrivateEndpointNetworkPoliciesDisabled)` which equals "Disabled". Using `optional(string, "Disabled")` in the object type definition provides the same default behavior.

### ForceNew

**Analysis:** The field does NOT have `ForceNew: true` in the schema, and there is no CustomizeDiff function that would trigger ForceNew behavior for this field.

**Evidence from Update method:**

```go
func resourceVirtualNetworkUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	if d.HasChange("subnet") {
		subnets, routeTables, err := expandVirtualNetworkSubnets(ctx, *client, d.Get("subnet").(*pluginsdk.Set).List(), *id)
		if err != nil {
			return fmt.Errorf("expanding `subnet`: %+v", err)
		}
		payload.Properties.Subnets = subnets
		// ...
	}
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, *id, *payload); err != nil {
		return fmt.Errorf("updating %s: %+v", id, err)
	}
	// ...
}
```

The Update method allows changes to the subnet block including the `private_endpoint_network_policies` field.

**Conclusion:** No ForceNew handling required. The field can be updated in-place.

### Sensitive

**Analysis:** The field is NOT marked as `Sensitive: true` in the schema and does not contain sensitive data.

**Conclusion:** No sensitive handling required. The field is included in `local.body`, not `local.sensitive_body`.

## Deferred Work Completion

Checked `following.md` - file does not exist, indicating no work has been deferred to this task.

## Critical Review & Edge Case Analysis

### Null Semantics

**Question:** What does `null` mean for this field?

**Analysis:** The field has `Optional: true` with a `Default` value. In Terraform object types with `optional()`, when not specified, the default value "Disabled" is used.

**Implementation:** Using `optional(string, "Disabled")` ensures that when users don't specify this field, it defaults to "Disabled" matching the provider behavior.

### Edge Cases

1. **Empty string:** The validation ensures only the four allowed values are accepted, so empty strings will be rejected at plan time.

2. **Case sensitivity:** The provider uses `validation.StringInSlice(..., false)` where the `false` parameter indicates case-sensitive matching. Our validation uses `contains()` with exact string matching, maintaining case sensitivity.

3. **Default value application:** When the subnet block is provided but `private_endpoint_network_policies` is omitted, the `optional(string, "Disabled")` syntax ensures "Disabled" is used, matching the provider's Default behavior.

4. **Update scenarios:** The field can be changed during updates without triggering resource replacement, allowing users to modify network policies on existing subnets.

### Idempotency

**Analysis:** The implementation is idempotent:
- Same input always produces same output
- No order-dependent operations
- Direct value pass-through with consistent type conversion

**Evidence:** The field is simply assigned: `privateEndpointNetworkPolicies = subnet.private_endpoint_network_policies`

### Safe References

**Analysis:** The field access is safe because:
- The field is accessed within the subnet iteration: `for subnet in var.subnet`
- The entire subnets array construction is conditional: `(var.subnet != null && length(var.subnet) > 0) ? [...] : null`
- The field has a default value via `optional(string, "Disabled")`, so it's never `null` within a subnet object

**No nested access issues:** The field is a direct property of the subnet object with no nested traversal required.

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew: Not applicable (field is not ForceNew)
- ✅ ALL logic EXACTLY replicated from provider (direct enum value assignment)
- ✅ Validations IMPLEMENTED in variables.tf (enum value validation)
- ✅ TODO comment: Not applicable (no sensitive field migration)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: Not applicable (no work deferred)
- ✅ Deferred work from following.md: Checked (file doesn't exist)
- ✅ Critical review (null semantics: default to "Disabled", edge cases: validation catches invalid values, idempotent: yes, safe refs: yes)
- ✅ Edge Case Analysis in proof (included above)
- ✅ Proof created
- ✅ Self-Review: Only implemented `subnet.private_endpoint_network_policies` field (Task #24). Did not add fields from other tasks.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #24 - subnet.private_endpoint_network_policies

### Validation Results

✅ **Default Value:** Correctly uses `optional(string, "Disabled")` - preferred method from executor.md
✅ **Validation:** Enum validation properly implemented in variables.tf (lines 271-276)
✅ **Phase Detection:** Correctly identified as Create Phase, placed in `local.body`
✅ **Assignment Path:** Verified path matches provider: `properties.subnets[].properties.privateEndpointNetworkPolicies`
✅ **ForceNew Logic:** Correctly identified as NOT ForceNew (no entry in replace_triggers_external_values)
✅ **Type Conversion:** Direct string assignment from Terraform to Azure API (no conversion needed)
✅ **Null Handling:** Safe - field has default value, never null within subnet object
✅ **Validations:** All provider validations (StringInSlice) replicated exactly in variables.tf
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Properly analyzed - default application, case sensitivity, validation enforcement
✅ **Stable Keys:** Not applicable (no replace_triggers_external_values entry)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Points:**
- Uses preferred `optional(string, default)` method for nested default values (executor.md lines 146-149)
- Validation implemented in `variables.tf` as mandatory (executor.md lines 115-126)
- Direct value assignment with no unnecessary conditionals
- Correct phase detection and placement in `local.body`
- Proper handling of enum type with case-sensitive validation

**Status:** APPROVED ✅

---
