# Task #19 - ip_address_pool.number_of_ip_addresses Argument

## Summary

Implemented the `ip_address_pool.number_of_ip_addresses` argument which maps to `numberOfIpAddresses` in the Azure API structure. This is a Required field within the `ip_address_pool` block that specifies the number of IP addresses to allocate from the IPAM Pool. The value must be a string representing a positive integer.

## Shadow Implementation

```hcl
locals {
  body = { 
    properties = {
      addressSpace = {
        ipamPoolPrefixAllocations = (var.ip_address_pool != null && length(var.ip_address_pool) > 0) ? [
          for pool in var.ip_address_pool : {
            numberOfIpAddresses = pool.number_of_ip_addresses  # <-
            pool = {
              id = pool.id
            }
          }
        ] : null
      }
    }
  }
}
```

```hcl
# In variables.tf - Added validation for positive number string format
variable "ip_address_pool" {
  # ...
  validation {                                                                    # <-
    condition = var.ip_address_pool == null || alltrue([                         # <-
      for pool in var.ip_address_pool : can(regex("^[1-9]\\d*$", pool.number_of_ip_addresses))  # <-
    ])                                                                            # <-
    error_message = "`number_of_ip_addresses` must be a string that represents a positive number"  # <-
  }                                                                               # <-
}
```

## Create Phase Verification

**Query Result:**

From Task #17, the Create phase analysis shows:

```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	// ...
	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// No additional SDK calls after CreateOrUpdateThenPoll
}
```

**Pattern Identification:** Single-phase creation pattern (as documented in Task #17)
- Primary operation: `client.CreateOrUpdateThenPoll(ctx, id, vnet)`
- No post-creation operations

**Field Classification:** The `ip_address_pool.number_of_ip_addresses` argument is processed during the **Create phase** (within primary `CreateOrUpdateThenPoll` operation).

**Decision:** Implement in `local.body` as part of main resource creation.

## Assignment Path Verification

**Predicted Path:** `body.properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`

**Go Code Evidence:**

From `expandVirtualNetworkIPAddressPool`:

```go
func expandVirtualNetworkIPAddressPool(input []interface{}) *[]virtualnetworks.IPamPoolPrefixAllocation {
	if len(input) == 0 {
		return nil
	}

	outputs := make([]virtualnetworks.IPamPoolPrefixAllocation, 0)
	for _, v := range input {
		ipPoolRaw := v.(map[string]interface{})
		output := virtualnetworks.IPamPoolPrefixAllocation{}

		if v, ok := ipPoolRaw["number_of_ip_addresses"]; ok {
			output.NumberOfIPAddresses = pointer.To(v.(string))
		}

		if v, ok := ipPoolRaw["id"]; ok {
			output.Pool = &virtualnetworks.IPamPoolPrefixAllocationPool{
				Id: pointer.To(v.(string)),
			}
		}

		outputs = append(outputs, output)
	}

	return &outputs
}
```

**Assignment Trace:**
1. `ipPoolRaw["number_of_ip_addresses"]` → extracted from Terraform config
2. `output.NumberOfIPAddresses = pointer.To(v.(string))` → assigned directly to NumberOfIPAddresses field (no wrapping)
3. `properties.AddressSpace.IPamPoolPrefixAllocations = expandVirtualNetworkIPAddressPool(...)` → assigned to AddressSpace
4. In Create: `vnet.Properties = vnetProperties` → properties assigned to VirtualNetwork
5. API sends: `properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`

**Verified Path:** `properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`

**Path Comparison:** ✅ MATCH - Predicted path matches verified path.

## Provider Schema

```go
"ip_address_pool": {
	Type:         pluginsdk.TypeList,
	Optional:     true,
	MaxItems:     2,
	ExactlyOneOf: []string{"address_space", "ip_address_pool"},
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"number_of_ip_addresses": {
				Type:     pluginsdk.TypeString,
				Required: true,
				ValidateFunc: validation.StringMatch(
					regexp.MustCompile(`^[1-9]\d*$`),
					"`number_of_ip_addresses` must be a string that represents a positive number",
				),
			},
			// ... other fields
		},
	},
},
```

**Field Details:**
- **Type:** String (TypeString)
- **Required:** true
- **ValidateFunc:** `validation.StringMatch(regexp.MustCompile(`^[1-9]\d*$`), ...)` - validates the value is a string representing a positive integer
- **ForceNew:** false (not specified, meaning updates are allowed)

## Azure API Schema

**Path:** `properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`

**Type:** String

**Structure:**
- Located directly within each `ipamPoolPrefixAllocations` array element
- This field holds the number of IP addresses to allocate as a string

From the full Azure API schema query:
```
ipamPoolPrefixAllocations: List(ObjectWithOptionalAttrs(map[string]Type{
  "numberOfIpAddresses": String, 
  "pool": ObjectWithOptionalAttrs(map[string]Type{
    "id": String
  }, []string{"id"})
}, []string{"numberOfIpAddresses", "pool"}))
```

## Hidden Fields Check

**Expand Function Analysis:**

From `expandVirtualNetworkIPAddressPool`:

```go
if v, ok := ipPoolRaw["number_of_ip_addresses"]; ok {
	output.NumberOfIPAddresses = pointer.To(v.(string))
}
```

**Hidden Fields:** ❌ NONE

The expand function only processes the `number_of_ip_addresses` field from Terraform config. No hardcoded values or additional hidden fields are set.

## Mapping

- `ip_address_pool[].number_of_ip_addresses` (Terraform) → `numberOfIpAddresses` (Azure API)
- snake_case → camelCase transformation
- Direct string value assignment (no wrapping)

## Special Handling

### Validation

**Provider Validation:**

The provider schema uses `ValidateFunc: validation.StringMatch(regexp.MustCompile(`^[1-9]\d*$`), ...)` which validates:
- String must start with a digit from 1-9 (no leading zeros)
- Followed by zero or more digits (0-9)
- This ensures a positive integer string representation

**Implementation in variables.tf:**

Added validation block to enforce the positive number string format:

```hcl
validation {
  condition = var.ip_address_pool == null || alltrue([
    for pool in var.ip_address_pool : can(regex("^[1-9]\\d*$", pool.number_of_ip_addresses))
  ])
  error_message = "`number_of_ip_addresses` must be a string that represents a positive number"
}
```

This validation:
- ✅ Validates the format matches the regex `^[1-9]\d*$` (positive integer string)
- ✅ Uses `alltrue()` to validate each pool in the list
- ✅ Only validates when `var.ip_address_pool` is not null
- ✅ Uses the exact same error message as the provider
- ✅ Replicates the exact regex pattern from provider

**Why This is EXACT:**

The regex pattern `^[1-9]\\d*$` is IDENTICAL to the provider's validation. This ensures:
- ❌ Rejects: `"0"`, `"00"`, `"-5"`, `"0123"` (leading zeros), `""` (empty), `"abc"` (non-numeric)
- ✅ Accepts: `"1"`, `"100"`, `"9999"`, `"123456789"` (any positive integer as string)

### ForceNew

**Schema Analysis:** No `ForceNew: true` in schema for the `number_of_ip_addresses` field.

**CustomizeDiff Check:** No CustomizeDiff logic in the resource function (confirmed in Task #17).

**Decision:** No ForceNew handling needed. Updates are allowed.

### Sensitive/WriteOnly

**Schema Analysis:** No `Sensitive: true` or WriteOnly indicators for the `number_of_ip_addresses` field.

**Decision:** Not sensitive. Use `local.body` (not `sensitive_body`).

### Post-Creation Operations

**Pattern:** Single-phase creation (confirmed in Task #17).

**Decision:** No post-creation operations. Implement in `local.body`.

## Deferred Work Completion

**Check `following.md`:** File does not exist - no deferred work to complete.

## Critical Review & Edge Cases

### Null Semantics

**When `var.ip_address_pool` is `null`:**
- The entire `ipamPoolPrefixAllocations` array is `null`
- The `numberOfIpAddresses` field is never evaluated
- ✅ Correct: handled by parent block conditional

**When `pool.number_of_ip_addresses` is empty string `""`:**
- Provider expand function: `ipPoolRaw["number_of_ip_addresses"]` would return empty string
- Validation will catch this at plan time (regex requires at least one digit)
- ✅ Safe: validation prevents empty strings

**Note on Type:** The field is a STRING, not a number. This is intentional in the provider design, allowing for very large values that might exceed numeric type limits.

### Boundary Conditions

**String Format:**
- Must match regex `^[1-9]\d*$`
- ✅ Validation enforces format at plan time
- ✅ Provider uses same validation

**Value Range:**
- Provider does not enforce maximum value
- Azure API is responsible for validating reasonable ranges
- ✅ We replicate provider behavior: no max limit validation

**Leading Zeros:**
- Values like `"0100"` are rejected by regex
- ✅ Matches provider behavior exactly

### Idempotency

**Value Assignment:**
- Direct assignment: `numberOfIpAddresses = pool.number_of_ip_addresses`
- No transformations applied
- ✅ Same input produces same output every time

**List Ordering:**
- Parent `for` loop maintains order from `var.ip_address_pool`
- ✅ Deterministic: order preserved across applies

### Safe References

**Null Safety:**
- ✅ Parent block checks `var.ip_address_pool != null && length(var.ip_address_pool) > 0`
- ✅ Loop variable `pool` is always non-null within the `for` expression
- ✅ Field access `pool.number_of_ip_addresses` is safe (variable type definition ensures field exists)

**String Type:**
- ✅ Field is defined as `string` in variable type
- ✅ Direct assignment maintains type consistency
- ✅ No type conversion needed

## Edge Case Analysis

### Edge Case 1: Very Large Numbers

**Scenario:** User provides a very large number like `"999999999999999999999"`

**Provider Behavior:**
- Provider accepts any string matching the regex
- No size limit validation in provider
- Azure API validates if the number is reasonable for IPAM Pool allocation

**Our Implementation:**
- ✅ Matches provider: no maximum value validation
- ✅ Pass through as-is to Azure API
- ✅ Azure API is responsible for business logic validation

### Edge Case 2: Leading Zeros

**Scenario:** User provides `"0100"` or `"001"`

**Provider Behavior:**
- Validation fails: regex requires first digit to be 1-9
- User receives error at plan time

**Our Implementation:**
- ✅ Validation block catches this at plan time
- ✅ Same regex pattern as provider
- ✅ Same error behavior

### Edge Case 3: Zero Value

**Scenario:** User provides `"0"`

**Provider Behavior:**
- Validation fails: regex requires first digit to be 1-9
- This makes sense as allocating 0 IP addresses is meaningless

**Our Implementation:**
- ✅ Validation block rejects `"0"`
- ✅ Matches provider behavior exactly

### Edge Case 4: Negative Numbers

**Scenario:** User provides `"-100"`

**Provider Behavior:**
- Validation fails: regex does not allow `-` character
- Negative allocation doesn't make sense

**Our Implementation:**
- ✅ Validation block rejects negative numbers
- ✅ Matches provider behavior exactly

### Edge Case 5: Multiple Pools with Different Allocations

**Scenario:** User provides two pools with different `number_of_ip_addresses` values

**Provider Behavior:**
- Each pool allocation is independent
- Each value is validated separately
- All values sent to Azure API as-is

**Our Implementation:**
- ✅ `alltrue()` validates each pool independently
- ✅ Each value passed through to API without modification
- ✅ Matches provider: no cross-pool validation

### Edge Case 6: Empty ip_address_pool List

**Scenario:** `var.ip_address_pool = []`

**Provider Behavior:**
- `expandVirtualNetworkIPAddressPool` returns `nil` when length is 0
- No API field sent

**Our Implementation:**
- ✅ Parent block checks `length(var.ip_address_pool) > 0`
- ✅ Returns `null` for empty list
- ✅ Matches provider: `ignore_null_property = true` omits field from API call

### Edge Case 7: String vs Number Type

**Scenario:** User might be confused why this is a string, not a number

**Provider Behavior:**
- Field type is explicitly `TypeString`
- This allows arbitrarily large values without numeric overflow
- Provider validates string format with regex

**Our Implementation:**
- ✅ Variable type is `string`
- ✅ Validation enforces string format
- ✅ No type conversion attempted
- ✅ Matches provider design choice

## Checklist

- ✅ Field implemented in correct location (`local.body`)
- ✅ Assignment path verified (`properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`)
- ✅ Validation implemented in `variables.tf` (positive number string format with exact regex)
- ✅ ForceNew analysis complete (not needed)
- ✅ CustomizeDiff checked (none applicable)
- ✅ Sensitive/WriteOnly checked (not sensitive)
- ✅ Hidden fields checked (none found)
- ✅ Create phase verified (single-phase pattern)
- ✅ Post-creation operations checked (none)
- ✅ Deferred work checked (none)
- ✅ Null semantics reviewed
- ✅ Edge cases analyzed (large numbers, zeros, negatives, leading zeros, string type)
- ✅ Idempotency confirmed
- ✅ Safe references verified
- ✅ Mapping documented (`number_of_ip_addresses` → `numberOfIpAddresses`)
- ✅ Provider schema documented
- ✅ Azure API schema documented
- ✅ Proof document created
- ✅ Self-review: Only implemented Task #19 scope (ip_address_pool.number_of_ip_addresses)
- ✅ Ready to update track.md to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #19 - ip_address_pool.number_of_ip_addresses

### Validation Results

✅ **Implementation Location:** Field correctly placed in `local.body.properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses` (migrate_main.tf line 35)

✅ **Assignment Path:** VERIFIED - Path matches provider behavior exactly:
- Provider: `output.NumberOfIPAddresses = pointer.To(v.(string))`
- Implementation: `numberOfIpAddresses = pool.number_of_ip_addresses`
- API Path: `properties.addressSpace.ipamPoolPrefixAllocations[].numberOfIpAddresses`

✅ **Validation Implementation:** EXACT replication in `variables.tf` (lines 185-190):
- Regex pattern: `^[1-9]\\d*$` - IDENTICAL to provider
- Error message: IDENTICAL to provider
- Logic: `alltrue()` correctly validates each pool in list
- Condition: Validates only when `var.ip_address_pool` is not null

✅ **ForceNew Logic:** Correctly determined NOT needed:
- Schema: No `ForceNew: true` present
- CustomizeDiff: None applicable (verified in Task #17)
- Updates are allowed

✅ **Stable Keys:** Not applicable (field is not in `replace_triggers_external_values`)

✅ **Phase Detection:** Correctly placed in `local.body` (Create phase, single-phase pattern)

✅ **Type Conversion:** Direct string assignment - no conversion needed

✅ **Null Handling:** Correctly propagates null semantics:
- Parent block checks: `var.ip_address_pool != null && length(var.ip_address_pool) > 0`
- Field access is safe within loop context
- `ignore_null_property = true` handles null parent automatically

✅ **Validations:** ALL provider validations implemented:
- String format validation with exact regex `^[1-9]\\d*$`
- Applied to each pool in list via `alltrue()`
- Error message matches provider exactly

✅ **Sensitive/WriteOnly:** Correctly determined NOT sensitive:
- Field placed in `body` (not `sensitive_body`)
- No version tracking needed

✅ **Hidden Fields:** Correctly verified NONE exist in expand function

✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)

✅ **Deferred Work Recording:** No deferrals made by this task

✅ **Edge Cases:** Comprehensive analysis performed:
- Very large numbers: Passed through (matches provider)
- Leading zeros: Rejected by validation (matches provider)
- Zero value: Rejected by validation (matches provider)
- Negative numbers: Rejected by validation (matches provider)
- Empty list: Handled by parent conditional returning null
- String type rationale: Correctly identified and preserved

✅ **Proof Document Quality:** 
- All required sections present
- Go code evidence provided
- Assignment path traced completely
- Edge cases thoroughly analyzed
- Critical review questions answered
- No forbidden phrases found

### Compliance Statement

This implementation **EXACTLY** replicates the provider behavior as required by `executor.md`. 

**Specific Compliance Verification:**
1. **Validation**: Exact regex `^[1-9]\\d*$` replicated (executor.md Category 1 - Value Constraints)
2. **Assignment Path**: Verified through complete trace from provider source to API
3. **Null Semantics**: Parent block conditional correctly handles null cases
4. **No Shortcuts**: No simplifications or "safer alternatives" used
5. **Edge Cases**: All analyzed and handled identically to provider
6. **Error Messages**: Exact match to provider error messages

No deviations, simplifications, or "safer alternatives" were found. The implementation follows the EXACT method prescribed in executor.md for field validation and assignment.

**Status:** APPROVED ✅

---
