# Task #21: subnet.name Argument

## Summary
Implemented `subnet.name` argument for the `subnet` block in `azurerm_virtual_network`. The field maps to `name` at root level of each subnet object in Azure API's `properties.subnets` array. Added validation to ensure name is not empty, replicating provider's `StringIsNotEmpty` validation.

## Shadow Implementation

```hcl
# In variables.tf
variable "subnet" {
  # ... type definition ...
  
  validation {  # <-
    condition = var.subnet == null || alltrue([  # <-
      for s in var.subnet : s.name != null && s.name != ""  # <-
    ])  # <-
    error_message = "Each subnet's name must not be null or empty."  # <-
  }  # <-
}

# In migrate_main.tf (already implemented by Task #20)
locals {
  body = {
    properties = {
      subnets = (var.subnet != null && length(var.subnet) > 0) ? [
        for subnet in var.subnet : {
          name = subnet.name  # <-
          properties = {
            # Other fields...
          }
        }
      ] : null
    }
  }
}
```

## Create Phase Verification

### Pattern Identification
Queried `resourceVirtualNetworkCreate` to verify the creation pattern:

**Go Code Evidence:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... setup code ...
	
	vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
	if err != nil {
		return err
	}

	vnet := virtualnetworks.VirtualNetwork{
		Name:             pointer.To(id.VirtualNetworkName),
		ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Properties:       vnetProperties,  // <-- Properties including subnets
		Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	// ... locks and NSG processing ...

	if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	
	// ... post-creation waiter ...
}
```

**Decision:** Single-phase creation pattern. The `subnet.name` field is processed during the primary `CreateOrUpdateThenPoll` call as part of virtual network properties.

**Classification:** Create phase - `subnet.name` goes in `local.body.properties.subnets[].name`

## Assignment Path Verification

### Predicted Path
`body.properties.subnets[].name`

### Go Code Evidence

From `expandVirtualNetworkProperties`:
```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	routeTables := make([]string, 0)
	if subs := d.Get("subnet").(*pluginsdk.Set); subs.Len() > 0 {
		for _, subnet := range subs.List() {
			subnet := subnet.(map[string]interface{})

			name := subnet["name"].(string)
			log.Printf("[INFO] setting subnets inside vNet, processing %q", name)
			
			// Get existing subnet properties from API
			subnetObj, err := getExistingSubnet(ctx, client, id, name)
			if err != nil {
				return nil, nil, err
			}

			// Set the props from config and leave the rest intact
			subnetObj.Name = pointer.To(name)  // <-- NAME ASSIGNED HERE
			if subnetObj.Properties == nil {
				subnetObj.Properties = &virtualnetworks.SubnetPropertiesFormat{}
			}
			
			// ... set other properties ...
			
			subnets = append(subnets, *subnetObj)
		}
	}

	properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
		// ... other properties ...
		Subnets: &subnets,  // <-- Subnets (with Name field) assigned to Properties.Subnets
	}
	
	return properties, &routeTables, nil
}
```

From `resourceVirtualNetworkCreate`:
```go
vnet := virtualnetworks.VirtualNetwork{
	Properties: vnetProperties,  // <-- Properties (including Subnets) assigned here
}
```

**Traced Assignments:**
1. `name` variable extracted from config: `name := subnet["name"].(string)`
2. Assigned to subnet object: `subnetObj.Name = pointer.To(name)`
3. Subnet appended to array: `subnets = append(subnets, *subnetObj)`
4. Array assigned to properties: `Subnets: &subnets`
5. Properties assigned to VNet: `Properties: vnetProperties`

**Final Path:** `VirtualNetwork.Properties.Subnets[].Name`

### Verified Path
`body.properties.subnets[].name`

**Path Comparison:** ✅ MATCH - Predicted path matches traced path

## Provider Schema

**Field:** `subnet.name`

**Go Schema Definition:**
```go
"subnet": {
	Type:       pluginsdk.TypeSet,
	Optional:   true,
	Computed:   true,
	ConfigMode: pluginsdk.SchemaConfigModeAttr,
	Elem: &pluginsdk.Resource{
		Schema: map[string]*pluginsdk.Schema{
			"name": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			// ... other fields ...
		},
	},
},
```

**Key Attributes:**
- Type: `TypeString`
- Required: true
- ForceNew: false (not set, defaults to false)
- ValidateFunc: `validation.StringIsNotEmpty`
- No DiffSuppressFunc
- No CustomizeDiff
- No Default value

## Azure API Schema

**Property Path:** `body.properties.subnets[].name`

**API Schema Type:** `String`

**Description:** The name of the subnet. This is a required field at the root level of each subnet object in the `properties.subnets` array.

## Hidden Fields

No hidden fields detected for `subnet.name`. The provider directly assigns the value from configuration without any transformations or hardcoded additions.

**Go Code Evidence:**
```go
name := subnet["name"].(string)
// ... 
subnetObj.Name = pointer.To(name)  // Direct assignment, no transformations
```

## Naming Convention

**Provider Field:** `subnet.name` (snake_case, within set of objects)  
**Azure API Field:** `name` (camelCase)

The conversion is straightforward: the field name remains `name` (lowercase) in both Terraform and Azure API.

## Special Handling

### Validation

**Provider Validation:** `validation.StringIsNotEmpty`

**Implementation:** Added validation block in `variables.tf`:
```hcl
validation {
  condition = var.subnet == null || alltrue([
    for s in var.subnet : s.name != null && s.name != ""
  ])
  error_message = "Each subnet's name must not be null or empty."
}
```

**Rationale:** 
- Replicates provider's `StringIsNotEmpty` validation
- Ensures all subnets have non-empty names
- Fails fast at plan time (not during API call)
- Uses `alltrue()` to check each subnet in the set

### Required Field

The field is Required in the provider schema, meaning:
- Users MUST provide a name for each subnet
- The validation ensures this requirement is enforced
- Cannot be null or empty string

### No ForceNew Logic

The `subnet.name` field has no `ForceNew: true` in the schema and no CustomizeDiff logic. This means:
- Name changes are handled through updates
- No entry in `replace_triggers_external_values` needed
- The provider allows in-place modification of subnet names

### Structure Placement

**CRITICAL:** The `name` field is placed at the ROOT level of each subnet object, NOT under `properties`:
```hcl
subnets = [
  for subnet in var.subnet : {
    name = subnet.name           # <-- Root level
    properties = {
      # Other fields here
    }
  }
]
```

This placement was already implemented in Task #20 (skeleton) because it's structural requirement, not a field-specific implementation detail.

### Existing Subnet Handling

The provider calls `getExistingSubnet` before setting properties:
```go
subnetObj, err := getExistingSubnet(ctx, client, id, name)
```

This allows subnets to be managed both inline (in vnet resource) and as separate resources. However, this behavior is specific to the provider's read-merge-write pattern and cannot be directly replicated in AzAPI without explicit data source reads. Since this is the NAME field (used for identification), the existing behavior doesn't affect how we handle the value itself.

## Deferred Work Completion

**Status:** N/A - No work was deferred TO this task in `following.md` (file does not exist).

## Critical Review & Edge Cases

### Null Semantics
- `var.subnet == null` → No subnets created → Validation passes (skipped via `var.subnet == null` condition)
- `subnet.name == null` → Validation FAILS with clear error message
- `subnet.name == ""` → Validation FAILS (empty string not allowed)

### Boundary Conditions
- **Empty name:** Blocked by validation (`s.name != ""`)
- **Null name:** Blocked by validation (`s.name != null`)
- **Valid name:** Any non-empty string accepted

### Idempotency
- Direct assignment ensures idempotent behavior
- Same name always produces same output
- No order-dependent operations

### Safe References
- Validation checks `var.subnet == null` first before iterating
- For-each loop safely accesses `subnet.name` (guaranteed to exist due to type definition)
- No nested null-unsafe references

### Edge Case: Name Uniqueness

The Azure API requires unique subnet names within a virtual network. However, this is enforced by Azure API, not by the provider's schema validation. The provider schema uses `TypeSet` which automatically enforces uniqueness of the entire subnet object (including name), but doesn't have explicit name-only uniqueness validation.

**Decision:** We rely on:
1. Terraform's `set` type behavior (handles object-level uniqueness)
2. Azure API validation (enforces name uniqueness)
3. Our validation only checks for non-empty values (exact provider behavior)

This matches the provider's approach - no additional uniqueness validation in Terraform layer.

### Edge Case: Existing Subnet Read

The provider reads existing subnet state via `getExistingSubnet`. This special behavior allows managing subnets that exist outside the VNet resource. However, for the NAME field specifically:
- Name is used as the identifier for lookup
- We don't need to replicate the read behavior for the name itself
- The name is directly assigned from configuration

**No special handling required** for this task because name is the lookup key, not a value that needs preservation from existing state.

## Implementation Checklist

- ✅ Field already in correct position in `migrate_main.tf` (line 60, from Task #20)
- ✅ Validation block added to `variables.tf`
- ✅ Validation replicates `StringIsNotEmpty` logic exactly
- ✅ No ForceNew logic needed (not a ForceNew field)
- ✅ No sensitive handling needed (not sensitive)
- ✅ No hidden fields detected
- ✅ Correct placement verified (root level of subnet object, not under properties)
- ✅ Create phase verified (single-phase, primary CreateOrUpdateThenPoll)
- ✅ Assignment path traced and verified
- ✅ Edge cases analyzed (null, empty, uniqueness, existing subnet)
- ✅ Critical review performed
- ✅ Proof document created
- ✅ Track.md to be updated to "Pending for check"

## Self-Review Confirmation

**Did I add ONLY what this task requires?**  
✅ YES - Only validation for `subnet.name` field. The implementation in `migrate_main.tf` was already present from Task #20.

**Did I add hidden fields that belong to other tasks?**  
✅ NO - No hidden fields for this specific field.

**Did I add fields from other tasks?**  
✅ NO - Only worked on `subnet.name` validation.

**Did I add logic that belongs to other subnet field tasks?**  
✅ NO - Only added name validation, no logic for address_prefixes, default_outbound_access_enabled, etc.

**Verification:**
- Reviewed changes to `variables.tf` - only added validation block for name
- Reviewed `migrate_main.tf` - no changes made (implementation already existed from Task #20)
- Confirmed scope limited to Task #21 requirements

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-06
**Task:** #21 - subnet.name

### Validation Results

✅ **ForceNew Logic:** No ForceNew logic required (field is not ForceNew in provider schema, no CustomizeDiff)
✅ **Stable Keys:** N/A - field not in replace_triggers_external_values (correctly not ForceNew)
✅ **Phase Detection:** Field correctly placed in local.body during Create phase (single-phase pattern verified)
✅ **Type Conversion:** Direct string assignment, no conversion needed
✅ **Null Handling:** Validation correctly prevents null and empty string values
✅ **Validations:** Provider's StringIsNotEmpty validation exactly replicated in variables.tf validation block
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null, empty string, uniqueness, existing subnet handling)
✅ **Implementation Placement:** Field value already correctly placed at root level of subnet object by Task #20 (skeleton)
✅ **Scope Compliance:** Task only added validation; implementation was correctly left from Task #20

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The validation block precisely matches the provider's `validation.StringIsNotEmpty` logic. The field placement (root level of subnet object, not under properties) is architecturally correct and was properly implemented by the skeleton task. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
