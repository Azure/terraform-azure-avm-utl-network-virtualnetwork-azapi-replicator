# Task #12 - ddos_protection_plan - Block Structure Skeleton

## Summary

Created structure skeleton for the `ddos_protection_plan` block with conditional logic and comment placeholders for child arguments (Tasks #13-14). The block expands to two separate properties in the Azure API: `properties.ddosProtectionPlan` (object with `id` field) and `properties.enableDdosProtection` (boolean).

## Shadow Implementation

```hcl
locals {
  body = { 
    properties = {
      ddosProtectionPlan = var.ddos_protection_plan != null ? {
        # id = ... # Task #13  # <-
      } : null  # <-
      enableDdosProtection = var.ddos_protection_plan != null ? null : null # Task #14  # <-
    }
  }
}
```

## Create Phase Verification

**Query:** Examined Create method via `resourceVirtualNetworkCreate`

**Pattern:** Single-phase creation

**Go Code Evidence:**
```go
func resourceVirtualNetworkCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    vnetProperties, routeTables, err := expandVirtualNetworkProperties(ctx, *client, id, d)
    if err != nil {
        return err
    }
    // ...
    vnet := virtualnetworks.VirtualNetwork{
        Name:             pointer.To(id.VirtualNetworkName),
        ExtendedLocation: expandEdgeZoneModel(d.Get("edge_zone").(string)),
        Location:         pointer.To(location.Normalize(d.Get("location").(string))),
        Properties:       vnetProperties,  // <- DDoS protection plan included in Properties
        Tags:             tags.Expand(d.Get("tags").(map[string]interface{})),
    }
    // ...
    if err := client.CreateOrUpdateThenPoll(ctx, id, vnet); err != nil {
        return fmt.Errorf("creating %s: %+v", id, err)
    }
    // ...
}
```

**Classification:** The `ddos_protection_plan` block is processed in the primary Create phase via `expandVirtualNetworkProperties`, which is called before the main `CreateOrUpdateThenPoll` operation. No post-creation operations exist for this field.

**Decision:** Implement in `local.body.properties` as part of main resource creation (not a post-creation operation).

## Assignment Path Verification

**Predicted Path:**
- Terraform: `var.ddos_protection_plan.id` → Azure API: `properties.ddosProtectionPlan.id`
- Terraform: `var.ddos_protection_plan.enable` → Azure API: `properties.enableDdosProtection`

**Go Code Evidence:**

From `expandVirtualNetworkProperties`:
```go
func expandVirtualNetworkProperties(ctx context.Context, client virtualnetworks.VirtualNetworksClient, id commonids.VirtualNetworkId, d *pluginsdk.ResourceData) (*virtualnetworks.VirtualNetworkPropertiesFormat, *[]string, error) {
    // ...
    properties := &virtualnetworks.VirtualNetworkPropertiesFormat{
        AddressSpace: &virtualnetworks.AddressSpace{},
        DhcpOptions: &virtualnetworks.DhcpOptions{
            DnsServers: utils.ExpandStringSlice(d.Get("dns_servers").([]interface{})),
        },
        PrivateEndpointVNetPolicies: pointer.To(virtualnetworks.PrivateEndpointVNetPolicies(d.Get("private_endpoint_vnet_policies").(string))),
        Subnets:                     &subnets,
    }
    // ...
    if v, ok := d.GetOk("ddos_protection_plan"); ok {
        rawList := v.([]interface{})

        var ddosPPlan map[string]interface{}
        if len(rawList) > 0 {
            ddosPPlan = rawList[0].(map[string]interface{})
        }

        if v, ok := ddosPPlan["id"]; ok {
            id := v.(string)
            properties.DdosProtectionPlan = &virtualnetworks.SubResource{  // <- Assignment 1
                Id: &id,
            }
        }

        if v, ok := ddosPPlan["enable"]; ok {
            enable := v.(bool)
            properties.EnableDdosProtection = &enable  // <- Assignment 2
        }
    }
    // ...
    return properties, &routeTables, nil
}
```

From Create method:
```go
vnet := virtualnetworks.VirtualNetwork{
    Properties: vnetProperties,  // <- .Properties assignment adds nesting
}
```

**Verified Path:**
- `var.ddos_protection_plan.id` → `properties.DdosProtectionPlan` (SubResource) → `properties.ddosProtectionPlan.id` (Azure API)
- `var.ddos_protection_plan.enable` → `properties.EnableDdosProtection` → `properties.enableDdosProtection` (Azure API)

**Path Comparison:** ✅ Match - Both fields are assigned directly to the `properties` object returned by `expandVirtualNetworkProperties`, which becomes `vnet.Properties` in the SDK payload.

## Provider Schema

**Go Source:**
```go
"ddos_protection_plan": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "id": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ValidateFunc: ddosprotectionplans.ValidateDdosProtectionPlanID,
            },

            "enable": {
                Type:     pluginsdk.TypeBool,
                Required: true,
            },
        },
    },
},
```

**Key Attributes:**
- Type: List block (MaxItems: 1)
- Optional: true
- ForceNew: false (not specified)
- Child fields:
  - `id`: Required, string, validated as DDoS Protection Plan ID
  - `enable`: Required, bool

## Azure API Schema

**Query:** `Microsoft.Network/virtualNetworks@2024-07-01`

**Schema Extract:**
```
properties:ObjectWithOptionalAttrs(map[string]Type{
    "ddosProtectionPlan":ObjectWithOptionalAttrs(map[string]Type{
        "id":String
    }, []string{"id"}),
    "enableDdosProtection":Bool,
    ...
}, []string{..., "ddosProtectionPlan", ..., "enableDdosProtection", ...})
```

**Property Paths:**
- `body.properties.ddosProtectionPlan.id` - Optional, String
- `body.properties.enableDdosProtection` - Optional, Bool

## Hidden Fields

**Expand Function Analysis:**

Examined `expandVirtualNetworkProperties` for the `ddos_protection_plan` block expansion:

```go
if v, ok := d.GetOk("ddos_protection_plan"); ok {
    rawList := v.([]interface{})

    var ddosPPlan map[string]interface{}
    if len(rawList) > 0 {
        ddosPPlan = rawList[0].(map[string]interface{})
    }

    if v, ok := ddosPPlan["id"]; ok {
        id := v.(string)
        properties.DdosProtectionPlan = &virtualnetworks.SubResource{
            Id: &id,
        }
    }

    if v, ok := ddosPPlan["enable"]; ok {
        enable := v.(bool)
        properties.EnableDdosProtection = &enable
    }
}
```

**Result:** ✅ No hidden fields found. The expand function only processes the two declared schema fields (`id` and `enable`) and maps them to their respective Azure API properties without adding any hardcoded or computed values.

## Mapping

**Terraform → Azure API:**
- Block: `ddos_protection_plan` → Two separate properties:
  - `properties.ddosProtectionPlan` (object)
  - `properties.enableDdosProtection` (boolean)
- Field: `id` → `ddosProtectionPlan.id` (camelCase)
- Field: `enable` → `enableDdosProtection` (camelCase)

**Naming Convention:** snake_case → camelCase

## Special Handling

### Block Conditionality
- **Condition:** `var.ddos_protection_plan != null`
- **Reason:** The entire block is Optional in provider schema (MaxItems: 1, Optional: true)
- **Implementation:** Both `ddosProtectionPlan` and `enableDdosProtection` properties are conditionally included based on whether the block variable is set

### Two-Property Expansion
- **Pattern:** Single Terraform block expands to TWO separate Azure API properties
- **Properties:**
  1. `properties.ddosProtectionPlan` - Object containing the resource ID
  2. `properties.enableDdosProtection` - Boolean flag to enable/disable protection
- **Implementation:** Both properties use the same conditional check `var.ddos_protection_plan != null`

### Placeholder Comments
- Placeholders added for child field implementations (Tasks #13-14)
- Format: `# field = ... # Task #N`
- Child tasks will replace these placeholders with actual field values

## Child Task Delegation

The following child tasks are now **ready for delegation** after skeleton creation:

| Task # | Field | Type | Ready? |
|--------|-------|------|--------|
| 13 | ddos_protection_plan.id | Argument | ✅ Yes |
| 14 | ddos_protection_plan.enable | Argument | ✅ Yes |

Both child tasks can now proceed to implement their respective arguments within the skeleton structure created by this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Block null:** When `var.ddos_protection_plan == null`, both `ddosProtectionPlan` and `enableDdosProtection` are set to `null`, which will be ignored by Azure API due to `ignore_null_property = true`
- **Correct behavior:** Matches provider's expand function which only sets these properties when the block exists (`d.GetOk("ddos_protection_plan")`)

### Edge Cases
1. **Empty block:** With `ignore_null_property = true`, if child fields are null, the parent objects will be sent with null children, which Azure API will handle appropriately
2. **Partial configuration:** Child task validations (in variables.tf) will ensure both `id` and `enable` are provided when the block is set (both are Required in provider schema)

### Idempotency
- ✅ No order-dependent logic
- ✅ Deterministic output based solely on input variable
- ✅ Conditional structure ensures consistent API payload

### Safe References
- ✅ Conditional check `var.ddos_protection_plan != null` protects against null reference errors
- ✅ With `ignore_null_property = true`, null values in child fields won't cause issues
- ✅ Child tasks will implement field access with safe null handling

## Checklist

- ✅ Skeleton structure created for `ddos_protection_plan` block
- ✅ Conditional logic based on `var.ddos_protection_plan != null`
- ✅ Comment placeholders added for child arguments (Tasks #13-14)
- ✅ Two-property expansion pattern documented (ddosProtectionPlan + enableDdosProtection)
- ✅ Hidden fields checked - none found
- ✅ Create phase verified - single-phase, main body
- ✅ Assignment path traced and verified
- ✅ Child tasks identified as ready for delegation
- ✅ Critical review completed
- ✅ Edge case analysis performed
- ✅ Proof document created
- ✅ No content from other tasks added

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent  
**Date:** 2026-01-06  
**Task:** #12 - ddos_protection_plan

### Issues Identified

#### Issue 1: Incorrect Placeholder Implementation for enableDdosProtection

**Problem:**
The executor implemented the `enableDdosProtection` property with a faulty placeholder:
```hcl
enableDdosProtection = var.ddos_protection_plan != null ? null : null # Task #14
```

This always evaluates to `null` regardless of the condition, making it an ineffective placeholder. The conditional `condition ? null : null` is logically equivalent to just `null`.

**Why This Violates executor.md:**

From executor.md Type 3 (Block Structure Skeleton):
> **Create skeleton ONLY:**
> ```hcl
> locals {
>   body = {
>     properties = {
>       virtualMachineProfile = var.os_disk != null ? {
>         storageProfile = {
>           osDisk = {
>             # caching = ... # Task #88
>           }
>         }
>       } : null
>     }
>   }
> }
> ```

The correct pattern for Type 3 tasks is to use comment placeholders (e.g., `# field = ... # Task #N`) for fields that will be implemented by child tasks. The faulty conditional placeholder `null ? null : null` doesn't follow this pattern and would confuse Task #14 implementers.

**Provider's Actual Behavior:**

From the proof document's Go code evidence:
```go
if v, ok := ddosPPlan["enable"]; ok {
    enable := v.(bool)
    properties.EnableDdosProtection = &enable  // <- Sets the boolean value
}
```

The provider sets `EnableDdosProtection` to the actual boolean value from the block's `enable` field.

**Expected Behavior:**
- For Type 3 skeleton tasks: Use clean comment placeholders like `# enableDdosProtection = ... # Task #14`
- Task #14 will then replace this comment with the actual implementation: `enableDdosProtection = var.ddos_protection_plan != null ? var.ddos_protection_plan.enable : null`

**Root Cause:**
The executor attempted to create a "placeholder" using a conditional that always results in `null`, instead of using the standard comment placeholder pattern documented in executor.md for Type 3 tasks.

### Corrections Made

#### Fix 1: Replace Faulty Conditional with Proper Comment Placeholder

**Changed Files:**
- `migrate_main.tf`: Replaced `enableDdosProtection = var.ddos_protection_plan != null ? null : null # Task #14` with `# enableDdosProtection = ... # Task #14`

**New Implementation:**
```hcl
properties = {
  addressSpace = {
    addressPrefixes = local.effective_address_space
  }
  bgpCommunities = var.bgp_community != null ? {
    virtualNetworkCommunity = var.bgp_community
  } : null
  ddosProtectionPlan = var.ddos_protection_plan != null ? {
    # id = ... # Task #13
  } : null
  dhcpOptions = {
    dnsServers = var.dns_servers
  }
  # enableDdosProtection = ... # Task #14
  flowTimeoutInMinutes = var.flow_timeout_in_minutes
  privateEndpointVNetPolicies = var.private_endpoint_vnet_policies
}
```

**Why This is EXACT:**
- Follows the standard Type 3 skeleton pattern from executor.md
- Uses consistent comment placeholder syntax: `# field = ... # Task #N`
- Maintains clear skeleton structure for both child tasks (#13 and #14)
- Task #14 can cleanly replace the comment with actual implementation
- With `ignore_null_property = true`, the absence of this field in the skeleton doesn't cause issues

**Verification:**
- Scenario 1: Skeleton provides clear structure ✅
- Scenario 2: Task #13 can implement `id` field within `ddosProtectionPlan` object ✅
- Scenario 3: Task #14 can replace comment with `enableDdosProtection` implementation ✅
- Edge Case: Consistent placeholder pattern across all skeleton fields ✅

### Validation Results

✅ **Block Structure:** Skeleton correctly created for `ddos_protection_plan` block  
✅ **Conditional Logic:** Proper `var.ddos_protection_plan != null` check for `ddosProtectionPlan` object  
✅ **Placeholders:** Comment placeholders follow executor.md Type 3 pattern  
✅ **Two-Property Expansion:** Correctly identified and documented the pattern where one Terraform block expands to two Azure API properties  
✅ **Hidden Fields:** None found (verified in expand function)  
✅ **Phase Detection:** Correctly placed in `local.body` (Create phase)  
✅ **Assignment Path:** Verified through Go code tracing  
✅ **Child Task Readiness:** Tasks #13 and #14 can now proceed  
✅ **Edge Cases:** Null semantics properly analyzed  

### Compliance Statement

After corrections, this implementation EXACTLY follows executor.md rules for Type 3 (Block Structure Skeleton) tasks:
1. ✅ Creates skeleton structure with conditional logic
2. ✅ Uses proper comment placeholders for child fields
3. ✅ Documents the two-property expansion pattern
4. ✅ Provides clear guidance for child tasks #13 and #14
5. ✅ Follows consistent placeholder syntax throughout codebase

**Status:** CORRECTED AND APPROVED ✅

---
